/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.0
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.xuggle.xuggler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.xuggle.ferry.*;
/**
 * A file (or network data source) that contains one or more {@link 
 * IStream}  
 * objects of  
 * audio and video data.  
 * <p>  
 * Typical usage for reading looks like this:  
 * <pre>  
 * IContainer container = IContainer.make();  
 * if (container.open("myfile.flv", IContainer.Type.READ, null) <0) 
 *  
 * &nbsp;&nbsp;throw new RuntimeException("failed to open");  
 * int numStreams = container.getNumStreams();  
 * for(i = 0; i < numStreams; i++) {  
 * &nbsp;&nbsp;IStream stream = container.getStream(i);  
 * &nbsp;&nbsp;...query IStream for stream information...  
 * }  
 * IPacket packet = IPacket.make();  
 * while(container.readNextPacket(packet) >= 0)  
 * {  
 * &nbsp;&nbsp;... Do something with the packet...  
 * }  
 * container.close();  
 * </pre>  
 * <p>  
 * Typical usage for writing looks like this (makes an FLV file  
 * with one audio track encoded as mp3 data):  
 * </p>  
 * <pre>  
 * IContainer container = IContainer.make();  
 * if (container.open("myfile.flv", IContainer.Type.WRITE, null) <0) 
 *  
 * &nbsp;&nbsp;throw new RuntimeException("failed to open");  
 * IStream stream = container.addNewStream(0);  
 * IStreamCoder coder = stream.getStreamCoder();  
 * coder.setCodec(ICodec.ID.CODEC_ID_MP3);  
 * coder.setSampleRate(22050);  
 * coder.setChannels(2);  
 * coder.setBitRate(64000);  
 * if (coder.open()<0) throw new RuntimeException("could not open coder"); 
 *  
 * if (container.writeHeader() < 0) throw new RuntimeException();  
 * IPacket packet = IPacket.make();  
 * while( ... have more data to process ... ) {  
 *  
 * &nbsp;&nbsp;then assuming it generated an IPacket for you...  
 * &nbsp;&nbsp;if (container.writePacket(packet)<0)  
 * &nbsp;&nbsp;&nbsp;&nbsp;throw new RuntimeException("could not write 
 * packet");  
 * }  
 * if (container.writeTrailer() <0) throw new RuntimeException();  
 * container.close();  
 * </pre>  
 */
public class IContainer extends RefCounted implements com.xuggle.xuggler.IConfigurable {
  // JNIHelper.swg: Start generated code
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>
  /**
   * This method is only here to use some references and remove
   * a Eclipse compiler warning.
   */
  @SuppressWarnings("unused")
  private void noop()
  {
    IBuffer.make(null, 1);
  }
   
  private volatile long swigCPtr;

  /**
   * Internal Only.
   */
  protected IContainer(long cPtr, boolean cMemoryOwn) {
    super(XugglerJNI.SWIGIContainerUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }
  
  /**
   * Internal Only.
   */
  protected IContainer(long cPtr, boolean cMemoryOwn,
      java.util.concurrent.atomic.AtomicLong ref)
  {
    super(XugglerJNI.SWIGIContainerUpcast(cPtr),
     cMemoryOwn, ref);
    swigCPtr = cPtr;
  }
    
  /**
   * Internal Only.  Not part of public API.
   *
   * Get the raw value of the native object that obj is proxying for.
   *   
   * @param obj The java proxy object for a native object.
   * @return The raw pointer obj is proxying for.
   */
  public static long getCPtr(IContainer obj) {
    if (obj == null) return 0;
    return obj.getMyCPtr();
  }

  /**
   * Internal Only.  Not part of public API.
   *
   * Get the raw value of the native object that we're proxying for.
   *   
   * @return The raw pointer we're proxying for.
   */  
  public long getMyCPtr() {
    if (swigCPtr == 0) throw new IllegalStateException("underlying native object already deleted");
    return swigCPtr;
  }
  
  /**
   * Create a new IContainer object that is actually referring to the
   * exact same underlying native object.
   *
   * @return the new Java object.
   */
  @Override
  public IContainer copyReference() {
    if (swigCPtr == 0)
      return null;
    else
      return new IContainer(swigCPtr, swigCMemOwn, getJavaRefCount());
  }

  /**
   * Compares two values, returning true if the underlying objects in native code are the same object.
   *
   * That means you can have two different Java objects, but when you do a comparison, you'll find out
   * they are the EXACT same object.
   *
   * @return True if the underlying native object is the same.  False otherwise.
   */
  public boolean equals(Object obj) {
    boolean equal = false;
    if (obj instanceof IContainer)
      equal = (((IContainer)obj).swigCPtr == this.swigCPtr);
    return equal;
  }
  
  /**
   * Get a hashable value for this object.
   *
   * @return the hashable value.
   */
  public int hashCode() {
     return (int)swigCPtr;
  }
  
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<
  // JNIHelper.swg: End generated code
  

  /**
   * info about this container.  We only print information that can be
   * determined without reading data from the container.
   * @return a string representation of this object
   */
   
  @Override
  public String toString()
  {
    StringBuilder result = new StringBuilder();
    
    result.append(this.getClass().getName()+"@"+hashCode()+"[");
    result.append("url:"+getURL()+";");
    result.append("type:"+getType()+";");
    result.append("format:"+getContainerFormat()+";");
    result.append("]");
    return result.toString();
  }

  /**
   * Open this container and make it ready for reading or writing.
   * Reading or writing ability is determined by
   * what the {@link com.xuggle.xuggler.io.IURLProtocolHandler}
   * passed in supports.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    com.xuggle.xuggler.io.IURLProtocolHandler handler,
    IContainer.Type type, IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(handler), type, format); 
  }

  /**
   * Open this container and make it ready for writing.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    java.io.OutputStream output,
    IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(output),
     IContainer.Type.WRITE, format); 
  }

  /**
   * Open this container and make it ready for reading.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    java.io.InputStream input,
    IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(input),
     IContainer.Type.READ, format); 
  }

  /**
   * Open this container and make it ready for writing.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    java.io.DataOutput output,
    IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(output),
     IContainer.Type.WRITE, format); 
  }

  /**
   * Open this container and make it ready for writing.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    java.io.DataOutputStream output,
    IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(
        (java.io.OutputStream)output),
     IContainer.Type.WRITE, format); 
  }

  /**
   * Open this container and make it ready for reading.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    java.io.DataInput input,
    IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(input),
     IContainer.Type.READ, format); 
  }

  /**
   * Open this container and make it ready for reading.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    java.io.DataInputStream input,
    IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(
        (java.io.InputStream)input),
     IContainer.Type.READ, format); 
  }

  /**
   * Open this container and make it ready for reading or writing.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    java.io.RandomAccessFile file,
    IContainer.Type type,
    IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(file),
     type, format); 
  }

  /**
   * Open this container and make it ready for writing.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    java.nio.channels.WritableByteChannel output,
    IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(output),
     IContainer.Type.WRITE, format); 
  }

  /**
   * Open this container and make it ready for reading.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    java.nio.channels.ReadableByteChannel input,
    IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(input),
     IContainer.Type.READ, format); 
  }

  /**
   * Open this container and make it ready for reading or writing.
   * @see #open(String, IContainer.Type, IContainerFormat)
   */  
  public int open(
    java.nio.channels.ByteChannel channel,
    IContainer.Type type,
    IContainerFormat format)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(channel),
     type, format); 
  }


/**
 * Open this container and make it ready for reading or writing, optionally 
 * reading as far into the container as necessary to find all streams.
 * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
 */
  public int open(com.xuggle.xuggler.io.IURLProtocolHandler handler,
    IContainer.Type type, IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(handler), type, format,
      streamsCanBeAddedDynamically,
      queryStreamMetaData); 
  }

  /**
   * Open this container and make it ready for writing.
   * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
   */  
  public int open(
    java.io.OutputStream output,
    IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(output),
     IContainer.Type.WRITE, format, streamsCanBeAddedDynamically, queryStreamMetaData); 
  }

  /**
   * Open this container and make it ready for reading.
   * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
   */  
  public int open(
    java.io.InputStream input,
    IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(input),
     IContainer.Type.READ, format, streamsCanBeAddedDynamically, queryStreamMetaData); 
  }

  /**
   * Open this container and make it ready for writing.
   * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
   */  
  public int open(
    java.io.DataOutput output,
    IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(output),
     IContainer.Type.WRITE, format, streamsCanBeAddedDynamically, queryStreamMetaData); 
  }

  /**
   * Open this container and make it ready for writing.
   * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
   */  
  public int open(
    java.io.DataOutputStream output,
    IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(
        (java.io.OutputStream)output),
     IContainer.Type.WRITE, format, streamsCanBeAddedDynamically, queryStreamMetaData); 
  }

  /**
   * Open this container and make it ready for reading.
   * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
   */  
  public int open(
    java.io.DataInput input,
    IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(input),
     IContainer.Type.READ, format, streamsCanBeAddedDynamically, queryStreamMetaData); 
  }

  /**
   * Open this container and make it ready for reading.
   * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
   */  
  public int open(
    java.io.DataInputStream input,
    IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(
        (java.io.InputStream)input),
     IContainer.Type.READ, format, streamsCanBeAddedDynamically, queryStreamMetaData); 
  }
  
  /**
   * Open this container and make it ready for reading or writing.
   * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
   */  
  public int open(
    java.io.RandomAccessFile file,
    IContainer.Type type,
    IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(file),
     type, format, streamsCanBeAddedDynamically, queryStreamMetaData); 
  }

  /**
   * Open this container and make it ready for writing.
   * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
   */  
  public int open(
    java.nio.channels.WritableByteChannel output,
    IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(output),
     IContainer.Type.WRITE, format, streamsCanBeAddedDynamically, queryStreamMetaData); 
  }

  /**
   * Open this container and make it ready for reading.
   * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
   */  
  public int open(
    java.nio.channels.ReadableByteChannel input,
    IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(input),
     IContainer.Type.READ, format, streamsCanBeAddedDynamically, queryStreamMetaData); 
  }

  /**
   * Open this container and make it ready for reading or writing.
   * @see #open(String, IContainer.Type, IContainerFormat, boolean, boolean) 
   */  
  public int open(
    java.nio.channels.ByteChannel channel,
    IContainer.Type type,
    IContainerFormat format,
    boolean streamsCanBeAddedDynamically,
    boolean queryStreamMetaData)
  {
    return open(com.xuggle.xuggler.io.XugglerIO.map(channel),
     type, format, streamsCanBeAddedDynamically, queryStreamMetaData); 
  }

  /**
   * Gets the SDP data as a Java string.
   * <p>
   * This method only supports SDP files up to 4K in size.
   * If you have a larger SDP file, use the
   * {@link #createSDPData(com.xuggle.ferry.IBuffer)} method and pass in your
   * own {@link com.xuggle.ferry.IBuffer} object.
   * </p> 
   * @return A {@link String} representing the data.
   * @see #createSDPData(IBuffer)
   */
  public String createSDPData()
  {
    IBuffer buffer = IBuffer.make(null, 4096);
    int len = this.createSDPData(buffer);
    if (len > 1)
    {
      byte [] stringBuf = new byte[len-1];
      buffer.get(0, stringBuf, 0, stringBuf.length);
      return new String(stringBuf);
    }
    return null;
  }
  /**
   * {@inheritDoc}
   */
  public java.util.Collection<String> getPropertyNames()
  {
    java.util.Collection<String> retval = new java.util.LinkedList<String>();
    int numProperties = this.getNumProperties();
    for(int i = 0; i < numProperties; i++)
    {
      IProperty property = this.getPropertyMetaData(i);
      String name = property.getName();
      retval.add(name);
    }
    return retval;
  }

  

/**
 * Set the buffer length Xuggler will suggest to FFMPEG for reading 
 * inputs.  
 * If called when a IContainer is open, the call is ignored and -1 is 
 * returned.  
 * @param	size The suggested buffer size.  
 * @return	size on success; <0 on error.  
 */
  public int setInputBufferLength(long size) {
    return XugglerJNI.IContainer_setInputBufferLength(swigCPtr, this, size);
  }

/**
 * Return the input buffer length.  
 * @return	The input buffer length Xuggler's told FFMPEG to assume. 
 *		  
 * 0 means FFMPEG should choose it's own  
 * size (and it'll probably be 32768).  
 */
  public long getInputBufferLength() {
    return XugglerJNI.IContainer_getInputBufferLength(swigCPtr, this);
  }

/**
 * Is this container opened?  
 * @return	true if opened; false if not.  
 */
  public boolean isOpened() {
    return XugglerJNI.IContainer_isOpened(swigCPtr, this);
  }

/**
 * Has a header been successfully written?  
 * @return	true if yes, false if no.  
 */
  public boolean isHeaderWritten() {
    return XugglerJNI.IContainer_isHeaderWritten(swigCPtr, this);
  }

/**
 * Open this container and make it ready for reading or writing.  
 * <p>  
 * The caller must call {@link #close()} when done, but if not, the 
 *  
 * {@link IContainer} will eventually close  
 * them later but warn to the logging system.  
 * </p>  
 * <p>  
 * This just forwards to {@link #open(String, Type, IContainerFormat, 
 * boolean, boolean)}  
 * passing false for aStreamsCanBeAddedDynamically, and true for aLookForAllStreams. 
 *  
 * </p><p>If the current thread is interrupted while this blocking method 
 *  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @param	url The resource to open; The format of this string is any 
 *		  
 * url that FFMPEG supports (including additional protocols if added 
 *  
 * through the xuggler.io library).  
 * @param	type The type of this container.  
 * @param	pContainerFormat A pointer to a ContainerFormat object specifying 
 *		  
 * the format of this container, or 0 (NULL) if you want us to guess. 
 *  
 * @return	>= 0 on success; < 0 on error.  
 */
  public int open(String url, IContainer.Type type, IContainerFormat pContainerFormat) {
    return XugglerJNI.IContainer_open__SWIG_0(swigCPtr, this, url, type.swigValue(), IContainerFormat.getCPtr(pContainerFormat), pContainerFormat);
  }

/**
 * Open this container and make it ready for reading or writing, optionally 
 *  
 * reading as far into the container as necessary to find all streams. 
 *  
 * <p>The caller must call {@link #close()} when done, but if not, the 
 *  
 * {@link IContainer} will eventually close  
 * them later but warn to the logging system.  
 * </p><p>If the current thread is interrupted while this blocking method 
 *  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @param	url The resource to open; The format of this string is any 
 *		  
 * url that FFMPEG supports (including additional protocols if added 
 *  
 * through the xuggler.io library).  
 * @param	type The type of this container.  
 * @param	pContainerFormat A pointer to a ContainerFormat object specifying 
 *		  
 * the format of this container, or 0 (NULL) if you want us to guess. 
 *  
 * @param	aStreamsCanBeAddedDynamically If true, open() will expect 
 *		 that new  
 * streams can be added at any time, even after the format header has 
 * been read.  
 * @param	aQueryStreamMetaData If true, open() will call {@link #queryStreamMetaData()} 
 *		  
 * on this container, which will potentially block until it has ready 
 *  
 * enough data to find all streams in a container. If false, it will 
 * only  
 * block to read a minimal header for this container format.  
 * @return	>= 0 on success; < 0 on error.  
 */
  public int open(String url, IContainer.Type type, IContainerFormat pContainerFormat, boolean aStreamsCanBeAddedDynamically, boolean aQueryStreamMetaData) {
    return XugglerJNI.IContainer_open__SWIG_1(swigCPtr, this, url, type.swigValue(), IContainerFormat.getCPtr(pContainerFormat), pContainerFormat, aStreamsCanBeAddedDynamically, aQueryStreamMetaData);
  }

/**
 * Returns the IContainerFormat object being used for this IContainer, 
 *  
 * or null if the {@link IContainer} doesn't yet know.  
 * @return	the IContainerFormat object, or null.  
 */
  public IContainerFormat getContainerFormat() {
    long cPtr = XugglerJNI.IContainer_getContainerFormat(swigCPtr, this);
    return (cPtr == 0) ? null : new IContainerFormat(cPtr, false);
  }

/**
 * Close the container. open() must have been called first, or  
 * else an error is returned.<p>If the current thread is interrupted 
 * while this blocking method  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * <p>  
 * If this method exits because of an interruption,  
 * all resources will be closed anyway.  
 * </p>  
 * @return	>= 0 on success; < 0 on error.  
 */
  public int close() {
    return XugglerJNI.IContainer_close(swigCPtr, this);
  }

/**
 * Find out the type of this container.  
 * @return	The Type of this container.  
 * {@link IContainer.Type#READ} if not yet opened.  
 */
  public IContainer.Type getType() {
    return IContainer.Type.swigToEnum(XugglerJNI.IContainer_getType(swigCPtr, this));
  }

/**
 * The number of streams in this container.  
 * <p>If opened in {@link IContainer.Type#READ} mode, this will query 
 * the stream and find out  
 * how many streams are in it.</p><p>If opened in  
 * {@link IContainer.Type#WRITE} mode, this will return the number of 
 * streams  
 * the caller has added to date.</p><p>If the current thread is interrupted 
 * while this blocking method  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @return	The number of streams in this container.  
 */
  public int getNumStreams() {
    return XugglerJNI.IContainer_getNumStreams(swigCPtr, this);
  }

/**
 * Get the stream at the given position.  
 * @param	streamIndex the index of this stream in the container  
 * @return	The stream at that position in the container, or null if 
 *		 none there.  
 */
  public IStream getStream(long streamIndex) {
    long cPtr = XugglerJNI.IContainer_getStream(swigCPtr, this, streamIndex);
    return (cPtr == 0) ? null : new IStream(cPtr, false);
  }

/**
 * @deprecated	Use {@link #addNewStream(ICodec.ID)} instead.  
 * Creates a new stream in this container and returns it.  
 * @param	id A format-dependent id for this stream.  
 * @return	A new stream.  
 */
  @Deprecated public IStream addNewStream(int id) {
    long cPtr = XugglerJNI.IContainer_addNewStream__SWIG_0(swigCPtr, this, id);
    return (cPtr == 0) ? null : new IStream(cPtr, false);
  }

/**
 * Adds a header, if needed, for this container.  
 * <p>  
 * Call this AFTER you've added all streams you want to add,  
 * opened all IStreamCoders for those streams (with proper  
 * configuration) and  
 * before you write the first frame. If you attempt to write  
 * a header but haven't opened all codecs, this method will log  
 * a warning, and your output file will likely be corrupt.  
 * </p><p>If the current thread is interrupted while this blocking method 
 *  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @return	0 if successful. < 0 if not. Always -1 if this is  
 * a READ container.  
 */
  public int writeHeader() {
    return XugglerJNI.IContainer_writeHeader(swigCPtr, this);
  }

/**
 * Adds a trailer, if needed, for this container.  
 * Call this AFTER you've written all data you're going to write  
 * to this container but BEFORE you call  
 * {@link IStreamCoder#close()} on your {@link IStreamCoder}  
 * objects.  
 * <p>  
 * You must call {@link #writeHeader()} before you call  
 * this (and if you don't, the {@link IContainer}  
 * will warn loudly and not  
 * actually write the trailer).  
 * </p>  
 * <p>  
 * If you have closed any of the {@link IStreamCoder} objects  
 * that were open when you called  
 * {@link #writeHeader()}, then this method will fail.  
 * </p><p>If the current thread is interrupted while this blocking method 
 *  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @return	0 if successful. < 0 if not. Always <0 if this is  
 * a READ container.  
 */
  public int writeTrailer() {
    return XugglerJNI.IContainer_writeTrailer(swigCPtr, this);
  }

/**
 * Reads the next packet into the IPacket. This method will  
 * release any buffers currently held by this packet and allocate  
 * new ones.  
 * <p>If the current thread is interrupted while this blocking method 
 *  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @param	packet [In/Out] The packet the IContainer will read into. 
 *		  
 * @return	0 if successful, or <0 if not.  
 */
  public int readNextPacket(IPacket packet) {
    return XugglerJNI.IContainer_readNextPacket(swigCPtr, this, IPacket.getCPtr(packet), packet);
  }

/**
 * Writes the contents of the packet to the container.  
 * <p>If the current thread is interrupted while this blocking method 
 *  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @param	packet [In] The packet to write out.  
 * @param	forceInterleave [In] If true, then this {@link IContainer} 
 *		 will  
 * make sure all packets  
 * are interleaved by DTS (even across streams in a container).  
 * If false, the {@link IContainer} won't,  
 * and it's up to the caller to interleave if necessary.  
 * @return	# of bytes written if successful, or <0 if not.  
 */
  public int writePacket(IPacket packet, boolean forceInterleave) {
    return XugglerJNI.IContainer_writePacket__SWIG_0(swigCPtr, this, IPacket.getCPtr(packet), packet, forceInterleave);
  }

/**
 * Writes the contents of the packet to the container, but make sure 
 * the  
 * packets are interleaved.  
 * <p>  
 * This means the {@link IContainer} may have to queue up packets from 
 * one  
 * stream while waiting for packets from another.  
 * </p><p>If the current thread is interrupted while this blocking method 
 *  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @param	packet [In] The packet to write out.  
 * @return	# of bytes written if successful, or <0 if not.  
 */
  public int writePacket(IPacket packet) {
    return XugglerJNI.IContainer_writePacket__SWIG_1(swigCPtr, this, IPacket.getCPtr(packet), packet);
  }

/**
 * Create a new container object.  
 * @return	a new container, or null on error.  
 */
  public static IContainer make() {
    long cPtr = XugglerJNI.IContainer_make__SWIG_0();
    return (cPtr == 0) ? null : new IContainer(cPtr, false);
  }

/**
 * Attempts to read all the meta data in this stream, potentially by 
 * reading ahead  
 * and decoding packets.  
 * <p>  
 * Any packets this method reads ahead will be cached and correctly 
 * returned when you  
 * read packets, but this method can be non-blocking potentially until 
 * end of container  
 * to get all meta data. Take care when you call it.  
 * </p><p>After this method is called, other meta data methods like 
 * {@link #getDuration()} should  
 * work.</p> <p>If the current thread is interrupted while this blocking 
 * method  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @return	>= 0 on success; <0 on failure.  
 */
  public int queryStreamMetaData() {
    return XugglerJNI.IContainer_queryStreamMetaData(swigCPtr, this);
  }

/**
 * Seeks to the key frame at (or the first one after) the given timestamp. 
 * This method will  
 * always fail for any IContainer that is not seekable (e.g. is streamed). 
 * When successful  
 * the next call to {@link #readNextPacket(IPacket)} will get the next 
 * keyframe from the  
 * sought for stream.<p>If the current thread is interrupted while this 
 * blocking method  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * <p>  
 * <strong>WARNING:</strong>: This method will be deprecated  
 * in a future Xuggler release and replaced with the new  
 * API {@link #seekKeyFrame(int, long, long, long, int)}.  
 * </p>  
 * @param	streamIndex The stream to search for the keyframe in; must 
 *		 be a  
 * stream the IContainer has either queried  
 * meta-data about or already ready a packet for.  
 * @param	timestamp The timestamp, in the timebase of the stream you're 
 *		 looking in (not necessarily Microseconds).  
 * @param	flags Flags to pass to com.xuggle.xuggler.io.IURLProtocolHandler's 
 *		 seek method.  
 * @return	>= 0 on success; <0 on failure.  
 */
  public int seekKeyFrame(int streamIndex, long timestamp, int flags) {
    return XugglerJNI.IContainer_seekKeyFrame__SWIG_0(swigCPtr, this, streamIndex, timestamp, flags);
  }

/**
 * Gets the duration, if known, of this container.  
 * This will only work for non-streamable containers where IContainer 
 *  
 * can calculate the container size.  
 * @return	The duration, or {@link Global#NO_PTS} if not known.  
 */
  public long getDuration() {
    return XugglerJNI.IContainer_getDuration(swigCPtr, this);
  }

/**
 * Get the starting timestamp in microseconds of the first packet of 
 * the earliest stream in this container.  
 * <p>  
 * This will only return value values either either (a) for non-streamable 
 *  
 *  
 * (b) after IContainer has actually read the  
 * first packet from a streamable source.  
 * </p>  
 * @return	The starting timestamp in microseconds, or {@link Global#NO_PTS} 
 *		 if not known.  
 */
  public long getStartTime() {
    return XugglerJNI.IContainer_getStartTime(swigCPtr, this);
  }

/**
 * Get the file size in bytes of this container.  
 * This will only return a valid value if the container is non-streamed 
 * and supports seek.  
 * @return	The file size in bytes, or <0 on error.  
 */
  public long getFileSize() {
    return XugglerJNI.IContainer_getFileSize(swigCPtr, this);
  }

/**
 * Get the calculated overall bit rate of this file.  
 * <p>  
 * This will only return a valid value if the container is non-streamed 
 * and supports seek.  
 * </p>  
 * @return	The overall bit rate in bytes per second, or <0 on error. 
 *		  
 */
  public int getBitRate() {
    return XugglerJNI.IContainer_getBitRate(swigCPtr, this);
  }

/**
 * Returns the total number of settable properties on this object  
 * @return	total number of options (not including constant definitions) 
 *		  
 */
  public int getNumProperties() {
    return XugglerJNI.IContainer_getNumProperties(swigCPtr, this);
  }

/**
 * Returns the name of the numbered property.  
 * @param	propertyNo The property number in the options list.  
 * @return	an IProperty value for this properties meta-data  
 */
  public IProperty getPropertyMetaData(int propertyNo) {
    long cPtr = XugglerJNI.IContainer_getPropertyMetaData__SWIG_0(swigCPtr, this, propertyNo);
    return (cPtr == 0) ? null : new IProperty(cPtr, false);
  }

/**
 * Returns the name of the numbered property.  
 * @param	name The property name.  
 * @return	an IProperty value for this properties meta-data  
 */
  public IProperty getPropertyMetaData(String name) {
    long cPtr = XugglerJNI.IContainer_getPropertyMetaData__SWIG_1(swigCPtr, this, name);
    return (cPtr == 0) ? null : new IProperty(cPtr, false);
  }

/**
 * Sets a property on this Object.  
 * All AVOptions supported by the underlying AVClass are supported. 
 *  
 * @param	name The property name. For example "b" for bit-rate.  
 * @param	value The value of the property.  
 * @return	>= 0 if the property was successfully set; <0 on error  
 */
  public int setProperty(String name, String value) {
    return XugglerJNI.IContainer_setProperty__SWIG_0(swigCPtr, this, name, value);
  }

/**
 * Looks up the property 'name' and sets the  
 * value of the property to 'value'.  
 * @param	name name of option  
 * @param	value Value of option  
 * @return	>= 0 on success; <0 on error.  
 */
  public int setProperty(String name, double value) {
    return XugglerJNI.IContainer_setProperty__SWIG_1(swigCPtr, this, name, value);
  }

/**
 * Looks up the property 'name' and sets the  
 * value of the property to 'value'.  
 * @param	name name of option  
 * @param	value Value of option  
 * @return	>= 0 on success; <0 on error.  
 */
  public int setProperty(String name, long value) {
    return XugglerJNI.IContainer_setProperty__SWIG_2(swigCPtr, this, name, value);
  }

/**
 * Looks up the property 'name' and sets the  
 * value of the property to 'value'.  
 * @param	name name of option  
 * @param	value Value of option  
 * @return	>= 0 on success; <0 on error.  
 */
  public int setProperty(String name, boolean value) {
    return XugglerJNI.IContainer_setProperty__SWIG_3(swigCPtr, this, name, value);
  }

/**
 * Looks up the property 'name' and sets the  
 * value of the property to 'value'.  
 * @param	name name of option  
 * @param	value Value of option  
 * @return	>= 0 on success; <0 on error.  
 */
  public int setProperty(String name, IRational value) {
    return XugglerJNI.IContainer_setProperty__SWIG_4(swigCPtr, this, name, IRational.getCPtr(value), value);
  }

/**
 * Gets a property on this Object.  
 * <p>  
 * Note for C++ callers; you must free the returned array with  
 * delete[] in order to avoid a memory leak. If you call  
 * from Java or any other language, you don't need to worry  
 * about this.  
 * </p>  
 * @param	name property name  
 * @return	an string copy of the option value, or null if the option 
 *		 doesn't exist.  
 */
  public String getPropertyAsString(String name) {
    return XugglerJNI.IContainer_getPropertyAsString(swigCPtr, this, name);
  }

/**
 * Gets the value of this property, and returns as a double;  
 * @param	name name of option  
 * @return	double value of property, or 0 on error.  
 */
  public double getPropertyAsDouble(String name) {
    return XugglerJNI.IContainer_getPropertyAsDouble(swigCPtr, this, name);
  }

/**
 * Gets the value of this property, and returns as an long;  
 * @param	name name of option  
 * @return	long value of property, or 0 on error.  
 */
  public long getPropertyAsLong(String name) {
    return XugglerJNI.IContainer_getPropertyAsLong(swigCPtr, this, name);
  }

/**
 * Gets the value of this property, and returns as an IRational;  
 * @param	name name of option  
 * @return	long value of property, or 0 on error.  
 */
  public IRational getPropertyAsRational(String name) {
    long cPtr = XugglerJNI.IContainer_getPropertyAsRational(swigCPtr, this, name);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

/**
 * Gets the value of this property, and returns as a boolean  
 * @param	name name of option  
 * @return	boolean value of property, or false on error.  
 */
  public boolean getPropertyAsBoolean(String name) {
    return XugglerJNI.IContainer_getPropertyAsBoolean(swigCPtr, this, name);
  }

/**
 * Get the flags associated with this object.  
 * @return	The (compacted) value of all flags set.  
 */
  public int getFlags() {
    return XugglerJNI.IContainer_getFlags(swigCPtr, this);
  }

/**
 * Set the flags to use with this object. All values  
 * must be ORed (|) together.  
 * @see		Flags  
 * @param	newFlags The new set flags for this codec.  
 */
  public void setFlags(int newFlags) {
    XugglerJNI.IContainer_setFlags(swigCPtr, this, newFlags);
  }

/**
 * Get the setting for the specified flag  
 * @param	flag The flag you want to find the setting for  
 * @return	0 for false; non-zero for true  
 */
  public boolean getFlag(IContainer.Flags flag) {
    return XugglerJNI.IContainer_getFlag(swigCPtr, this, flag.swigValue());
  }

/**
 * Set the flag.  
 * @param	flag The flag to set  
 * @param	value The value to set it to (true or false)  
 */
  public void setFlag(IContainer.Flags flag, boolean value) {
    XugglerJNI.IContainer_setFlag(swigCPtr, this, flag.swigValue(), value);
  }

/**
 * Get the URL the IContainer was opened with.  
 * May return null if unknown.  
 * @return	the URL opened, or null.  
 */
  public String getURL() {
    return XugglerJNI.IContainer_getURL(swigCPtr, this);
  }

/**
 * Flush all packets to output.  
 * <p>  
 * Will only work on {@link IContainer.Type#WRITE} containers.  
 * </p><p>If the current thread is interrupted while this blocking method 
 *  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @return	>= 0 on success; <0 on error  
 */
  public int flushPackets() {
    return XugglerJNI.IContainer_flushPackets(swigCPtr, this);
  }

/**
 * Get the number of times {@link IContainer#readNextPacket(IPacket)} 
 *  
 * will retry a read if it gets a {@link IError.Type#ERROR_AGAIN}  
 * value back.  
 * Defaults to 1 times. <0 means it will keep retrying indefinitely. 
 *  
 * @return	the read retry count  
 */
  public int getReadRetryCount() {
    return XugglerJNI.IContainer_getReadRetryCount(swigCPtr, this);
  }

/**
 * Sets the read retry count.  
 * @see		#getReadRetryCount()  
 * @param	count The read retry count. <0 means keep trying.  
 */
  public void setReadRetryCount(int count) {
    XugglerJNI.IContainer_setReadRetryCount(swigCPtr, this, count);
  }

/**
 * Can streams be added dynamically to this container?  
 * @return	true if streams can be added dynamically  
 */
  public boolean canStreamsBeAddedDynamically() {
    return XugglerJNI.IContainer_canStreamsBeAddedDynamically(swigCPtr, this);
  }

/**
 * Get the {@link IMetaData} for this object,  
 * or null if none.  
 * <p>  
 * If the {@link IContainer} or {@link IStream} object  
 * that this {@link IMetaData} came from was opened  
 * for reading, then changes via {@link IMetaData#setValue(String, String)} 
 *  
 * will have no effect on the underlying media.  
 * </p>  
 * <p>  
 * If the {@link IContainer} or {@link IStream} object  
 * that this {@link IMetaData} came from was opened  
 * for writing, then changes via {@link IMetaData#setValue(String, String)} 
 *  
 * will have no effect after {@link IContainer#writeHeader()}  
 * is called.  
 * </p>  
 * @return	the {@link IMetaData}.  
 */
  public IMetaData getMetaData() {
    long cPtr = XugglerJNI.IContainer_getMetaData(swigCPtr, this);
    return (cPtr == 0) ? null : new IMetaData(cPtr, false);
  }

/**
 * Set the {@link IMetaData} on this object, overriding  
 * any previous meta data. You should call this  
 * method on writable containers and  
 * before you call {@link IContainer#writeHeader}, as  
 * it probably won't do anything after that.  
 * @see		#getMetaData()  
 */
  public void setMetaData(IMetaData data) {
    XugglerJNI.IContainer_setMetaData(swigCPtr, this, IMetaData.getCPtr(data), data);
  }

/**
 * Fills the given buffer with a null-terminated ASCII  
 * set of bytes representing SDP data that  
 * is suitable for use with an RTSP-based system.  
 * <p>  
 * This method only works if Xuggler is linking  
 * against a version of FFmpeg that supports RTSP.  
 * </p>  
 * @param	buffer the {@link com.xuggle.ferry.IBuffer}  
 * object to fill with data.  
 * @return	the number of bytes written, including the  
 * terminating 0 byte, or < 0 on error.  
 */
  public int createSDPData(IBuffer buffer) {
    return XugglerJNI.IContainer_createSDPData(swigCPtr, this, IBuffer.getCPtr(buffer), buffer);
  }

/**
 * Forces the {@link IContainer} to assume all audio streams are  
 * encoded with the given audio codec when demuxing.  
 * @param	id The codec id  
 * @return	< 0 on error (e.g. not an audio codec); >= 0 on success. 
 *		  
 * @since	3.3  
 */
  public int setForcedAudioCodec(ICodec.ID id) {
    return XugglerJNI.IContainer_setForcedAudioCodec(swigCPtr, this, id.swigValue());
  }

/**
 * Forces the {@link IContainer} to assume all video streams are  
 * encoded with the given video codec when demuxing.  
 * @param	id The codec id  
 * @return	< 0 on error (e.g. not an video codec); >= 0 on success. 
 *		  
 * @since	3.3  
 */
  public int setForcedVideoCodec(ICodec.ID id) {
    return XugglerJNI.IContainer_setForcedVideoCodec(swigCPtr, this, id.swigValue());
  }

/**
 * Forces the {@link IContainer} to assume all subtitle streams are 
 *  
 * encoded with the given subtitle codec when demuxing.  
 * @param	id The codec id  
 * @return	< 0 on error (e.g. not an subtitle codec); >= 0 on success. 
 *		  
 * @since	3.3  
 */
  public int setForcedSubtitleCodec(ICodec.ID id) {
    return XugglerJNI.IContainer_setForcedSubtitleCodec(swigCPtr, this, id.swigValue());
  }

/**
 * EXPERIMENTAL - Seeks to timestamp in the container.  
 * <p>  
 * Seeking will be done so that the point from which all active streams 
 *  
 * can be presented successfully will be closest to  
 * <code>targetTimeStamp</code> and within <code>  
 * minTimeStamp/maxTimeStamp</code>.  
 * </p>  
 * <p>  
 * If flags contain {@link #SEEK_FLAG_BYTE}, then all time stamps are 
 * in bytes and  
 * are the file position (this may not be supported by all demuxers). 
 *  
 * If flags contain {@link #SEEK_FLAG_FRAME}, then all time stamps are 
 * in frames  
 * in the stream with <code>streamIndex</code> (this may not be supported 
 * by all demuxers).  
 * Otherwise all time stamps are in units of the stream selected by 
 * stream_index  
 * or if stream_index is -1, in microseconds.  
 * If flags contain {@link #SEEK_FLAG_ANY}, then non-keyframes are treated 
 * as  
 * keyframes (this may not be supported by all demuxers).  
 * If flags contain {@link #SEEK_FLAG_BACKWARDS}, then we will attempt 
 * to  
 * search backwards in the container (this may not be supported by all 
 *  
 * demuxers and file protocols).  
 * </p>  
 * <p>  
 * This is part of the new seek API which is still under construction. 
 *  
 * It may change in future Xuggler versions.  
 * </p>  
 * @param	streamIndex index of the stream which is used as time base 
 *		 reference  
 * @param	minTimeStamp smallest acceptable time stamp.  
 * @param	targetTimeStamp target time stamp.  
 * @param	maxTimeStamp largest acceptable time stamp.  
 * @param	flags A bitmask of the <code>SEEK_FLAG_*</code> flags, or 
 *		 0 to turn  
 * all flags off.  
 * @return	>=0 on success, error code otherwise  
 * @since	3.4  
 */
  public int seekKeyFrame(int streamIndex, long minTimeStamp, long targetTimeStamp, long maxTimeStamp, int flags) {
    return XugglerJNI.IContainer_seekKeyFrame__SWIG_1(swigCPtr, this, streamIndex, minTimeStamp, targetTimeStamp, maxTimeStamp, flags);
  }

/**
 * @deprecated	use {@link #setProperty} instead.  
 * If the container has not already been opened, sets the AVFormatContext.preload 
 * property  
 * which can be useful in some circumstances such as when dealing with 
 * mpeg formats.  
 * @param	preload amount to preload  
 * @return	>= 0 on success, error code otherwise  
 * @since	4.0  
 */
  @Deprecated public int setPreload(int preload) {
    return XugglerJNI.IContainer_setPreload(swigCPtr, this, preload);
  }

/**
 * @deprecated	use {@link #getPropertyAsLong} instead.  
 * The amount container will attemtp to preload.  
 * @return	The amount to preload, error code otherwise.  
 */
  @Deprecated public int getPreload() {
    return XugglerJNI.IContainer_getPreload(swigCPtr, this);
  }

/**
 * Sets the max delay for the AVFormatContext.max_delay property.  
 * @param	maxdelay maximum delay for container  
 * @return	>= 0 on success, error code otherwise  
 * @since	4.0  
 */
  public int setMaxDelay(int maxdelay) {
    return XugglerJNI.IContainer_setMaxDelay(swigCPtr, this, maxdelay);
  }

/**
 * Gets the AVFormatContext.max_delay property if possible.  
 * @return	The max delay, error code otherwise.  
 * @since	4.0  
 */
  public int getMaxDelay() {
    return XugglerJNI.IContainer_getMaxDelay(swigCPtr, this);
  }

/**
 * Add a new stream that will use the given codec.  
 * @param	id The id for the codec used to insert packets. If you are 
 *		 adding an arbitrary data stream, use {@link ICodec.ID#CODEC_ID_NONE}, 
 *		 otherwise  
 * use the ID of the code type you plan to use.  
 * @return	An {@link IStream} for the new stream on success, or null 
 *		 on failure.  
 * @since	5.0  
 */
  public IStream addNewStream(ICodec.ID id) {
    long cPtr = XugglerJNI.IContainer_addNewStream__SWIG_1(swigCPtr, this, id.swigValue());
    return (cPtr == 0) ? null : new IStream(cPtr, false);
  }

/**
 * Add a new stream that will use the given codec.  
 * @param	codec The codec that will be used to insert packets.  
 * @return	An {@link IStream} for the new stream on success, or null 
 *		 on failure.  
 * @since	5.0  
 */
  public IStream addNewStream(ICodec codec) {
    long cPtr = XugglerJNI.IContainer_addNewStream__SWIG_2(swigCPtr, this, ICodec.getCPtr(codec), codec);
    return (cPtr == 0) ? null : new IStream(cPtr, false);
  }

/**
 * Add a new stream that will use the given StreamCoder. The StreamCoder 
 * passed in MUST contain the {@link IStreamCoder#getExtraData} that 
 *  
 * was used to encode the packet.  
 * @param	coder The {@link IStreamCoder} that contains the meta-information 
 *		 needed for decoding the packets that will be muexed 
 *		 into this stream.  
 * @return	An {@link IStream} for the new stream on success, or null 
 *		 on failure.  
 * @since	5.0  
 */
  public IStream addNewStream(IStreamCoder coder) {
    long cPtr = XugglerJNI.IContainer_addNewStream__SWIG_3(swigCPtr, this, IStreamCoder.getCPtr(coder), coder);
    return (cPtr == 0) ? null : new IStream(cPtr, false);
  }

/**
 * {@inheritDoc}  
 */
  public int setProperty(IMetaData valuesToSet, IMetaData valuesNotFound) {
    return XugglerJNI.IContainer_setProperty__SWIG_5(swigCPtr, this, IMetaData.getCPtr(valuesToSet), valuesToSet, IMetaData.getCPtr(valuesNotFound), valuesNotFound);
  }

/**
 * Get the {@link IContainerFormat} that is used by this {@link IContainer}. 
 *  
 * @return	The format, or null if none is set yet.  
 * @since	5.0  
 */
  public IContainerFormat getFormat() {
    long cPtr = XugglerJNI.IContainer_getFormat(swigCPtr, this);
    return (cPtr == 0) ? null : new IContainerFormat(cPtr, false);
  }

/**
 * Set the {@link IContainerFormat} to use with this {@link IContainer}. 
 * If called when the  
 * {@link IContainer} is opened, or if previously called with a non-null 
 * value,  
 * an error is returned and no action is taken.  
 * @param	format The format to use  
 * return 0 on success; <0 on failure  
 * @since	5.0  
 */
  public int setFormat(IContainerFormat format) {
    return XugglerJNI.IContainer_setFormat(swigCPtr, this, IContainerFormat.getCPtr(format), format);
  }

/**
 * Create a new {@link IContainer} and call {@link #setFormat(IContainerFormat)} 
 * on it immediately.  
 * @param	format The format to pass to {@link #setFormat(IContainerFormat)} 
 *		  
 * @return	An {@link IContainer} on success, or null on failure.  
 * @since	5.0  
 */
  public static IContainer make(IContainerFormat format) {
    long cPtr = XugglerJNI.IContainer_make__SWIG_1(IContainerFormat.getCPtr(format), format);
    return (cPtr == 0) ? null : new IContainer(cPtr, false);
  }

/**
 * Open this container and make it ready for reading or writing, optionally 
 *  
 * reading as far into the container as necessary to find all streams. 
 *  
 * <p>The caller must call {@link #close()} when done, but if not, the 
 *  
 * {@link IContainer} will eventually close  
 * them later but warn to the logging system.  
 * </p><p>If the current thread is interrupted while this blocking method 
 *  
 * is running the method will return with a negative value.  
 * To check if the method exited because of an interruption  
 * pass the return value to {@link IError#make(int)} and then  
 * check {@link IError#getType()} to see if it is  
 * {@link IError.Type#ERROR_INTERRUPTED}.  
 * </p>  
 * @param	url The resource to open; The format of this string is any 
 *		  
 * url that FFMPEG supports (including additional protocols if added 
 *  
 * through the xuggler.io library).  
 * @param	type The type of this container.  
 * @param	containerFormat A pointer to a ContainerFormat object specifying 
 *		  
 * the format of this container, or 0 (NULL) if you want us to guess. 
 *  
 * @param	streamsCanBeAddedDynamically If true, open() will expect that 
 *		 new  
 * streams can be added at any time, even after the format header has 
 * been read.  
 * @param	queryStreamMetaData If true, open() will call {@link #queryStreamMetaData()} 
 *		  
 * on this container, which will potentially block until it has ready 
 *  
 * enough data to find all streams in a container. If false, it will 
 * only  
 * block to read a minimal header for this container format.  
 * @param	options If not null, a set of key-value pairs that will be 
 *		 set on the container immediately  
 * the format is determined. Some options cannot be set (especially 
 * for input containers) until the  
 * system has a chance to parse what data is in the file.  
 * @param	optionsNotSet If not null, on return this {@link IMetaData} 
 *		 object will be cleared out, and  
 * replace with any key/value pairs that were in <code>options</code> 
 * but could not be set on this  
 * {@link IContainer}.  
 * @return	>= 0 on success; < 0 on error.  
 * @since	5.0  
 */
  public int open(String url, IContainer.Type type, IContainerFormat containerFormat, boolean streamsCanBeAddedDynamically, boolean queryStreamMetaData, IMetaData options, IMetaData optionsNotSet) {
    return XugglerJNI.IContainer_open__SWIG_2(swigCPtr, this, url, type.swigValue(), IContainerFormat.getCPtr(containerFormat), containerFormat, streamsCanBeAddedDynamically, queryStreamMetaData, IMetaData.getCPtr(options), options, IMetaData.getCPtr(optionsNotSet), optionsNotSet);
  }

  public enum Type {
  /**
   *
   * may only be opened in a uni-directional mode.
   */
    READ,
    WRITE;

    public final int swigValue() {
      return swigValue;
    }

    public static Type swigToEnum(int swigValue) {
      Type[] swigValues = Type.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (Type swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + Type.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private Type() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private Type(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private Type(Type swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum Flags {
    FLAG_GENPTS(XugglerJNI.IContainer_FLAG_GENPTS_get()),
    FLAG_IGNIDX(XugglerJNI.IContainer_FLAG_IGNIDX_get()),
    FLAG_NONBLOCK(XugglerJNI.IContainer_FLAG_NONBLOCK_get()),
    FLAG_IGNDTS(XugglerJNI.IContainer_FLAG_IGNDTS_get()),
    FLAG_NOFILLIN(XugglerJNI.IContainer_FLAG_NOFILLIN_get()),
    FLAG_NOPARSE(XugglerJNI.IContainer_FLAG_NOPARSE_get()),
    FLAG_RTP_HINT(XugglerJNI.IContainer_FLAG_RTP_HINT_get());

    public final int swigValue() {
      return swigValue;
    }

    public static Flags swigToEnum(int swigValue) {
      Flags[] swigValues = Flags.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (Flags swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + Flags.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private Flags() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private Flags(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private Flags(Flags swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

/**
 * Flag; Seek backwards  
 */
  public final static int SEEK_FLAG_BACKWARDS = XugglerJNI.IContainer_SEEK_FLAG_BACKWARDS_get();
/**
 * Flag; Use bytes instead of time stamps for seeking  
 */
  public final static int SEEK_FLAG_BYTE = XugglerJNI.IContainer_SEEK_FLAG_BYTE_get();
/**
 * Flag; Seek to any frame, even non-keyframes  
 */
  public final static int SEEK_FLAG_ANY = XugglerJNI.IContainer_SEEK_FLAG_ANY_get();
/**
 * Flag; Seek based on frame number instead of time stamps  
 */
  public final static int SEEK_FLAG_FRAME = XugglerJNI.IContainer_SEEK_FLAG_FRAME_get();
}

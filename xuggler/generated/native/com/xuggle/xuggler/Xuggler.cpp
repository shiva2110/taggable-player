/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.0
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifdef __cplusplus
template<typename T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Fix for jlong on some versions of gcc on Windows */
#if defined(__GNUC__) && !defined(__INTELC__)
  typedef long long __int64;
#endif

/* Fix for jlong on 64-bit x86 Solaris */
#if defined(__x86_64)
# ifdef _LP64
#   undef _LP64
# endif
#endif

#include <jni.h>
#include <stdlib.h>
#include <string.h>


/* Support for throwing Java exceptions */
typedef enum {
  SWIG_JavaOutOfMemoryError = 1, 
  SWIG_JavaIOException, 
  SWIG_JavaRuntimeException, 
  SWIG_JavaIndexOutOfBoundsException,
  SWIG_JavaArithmeticException,
  SWIG_JavaIllegalArgumentException,
  SWIG_JavaNullPointerException,
  SWIG_JavaDirectorPureVirtual,
  SWIG_JavaUnknownError
} SWIG_JavaExceptionCodes;

typedef struct {
  SWIG_JavaExceptionCodes code;
  const char *java_exception;
} SWIG_JavaExceptions_t;


static void SWIGUNUSED SWIG_JavaThrowException(JNIEnv *jenv, SWIG_JavaExceptionCodes code, const char *msg) {
  jclass excep;
  static const SWIG_JavaExceptions_t java_exceptions[] = {
    { SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError" },
    { SWIG_JavaIOException, "java/io/IOException" },
    { SWIG_JavaRuntimeException, "java/lang/RuntimeException" },
    { SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException" },
    { SWIG_JavaArithmeticException, "java/lang/ArithmeticException" },
    { SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException" },
    { SWIG_JavaNullPointerException, "java/lang/NullPointerException" },
    { SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException" },
    { SWIG_JavaUnknownError,  "java/lang/UnknownError" },
    { (SWIG_JavaExceptionCodes)0,  "java/lang/UnknownError" } };
  const SWIG_JavaExceptions_t *except_ptr = java_exceptions;

  while (except_ptr->code != code && except_ptr->code)
    except_ptr++;

  jenv->ExceptionClear();
  excep = jenv->FindClass(except_ptr->java_exception);
  if (excep)
    jenv->ThrowNew(excep, msg);
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else



// Xuggler.i: Start generated code
// >>>>>>>>>>>>>>>>>>>>>>>>>>>
#include <com/xuggle/ferry/JNIHelper.h>
#include <com/xuggle/xuggler/IProperty.h>
#include <com/xuggle/xuggler/IPixelFormat.h>
#include <com/xuggle/xuggler/ITimeValue.h>
#include <com/xuggle/xuggler/IRational.h>
#include <com/xuggle/xuggler/IMetaData.h>
#include <com/xuggle/xuggler/IMediaData.h>
#include <com/xuggle/xuggler/IAudioSamples.h>
#include <com/xuggle/xuggler/ICodec.h>
#include <com/xuggle/xuggler/IPacket.h>
#include <com/xuggle/xuggler/IIndexEntry.h>
#include <com/xuggle/xuggler/IAudioResampler.h>
#include <com/xuggle/xuggler/IVideoPicture.h>
#include <com/xuggle/xuggler/IVideoResampler.h>
#include <com/xuggle/xuggler/IStreamCoder.h>
#include <com/xuggle/xuggler/IStream.h>
#include <com/xuggle/xuggler/IContainerFormat.h>
#include <com/xuggle/xuggler/IContainer.h>
#include <com/xuggle/xuggler/IMediaDataWrapper.h>
#include <com/xuggle/xuggler/Global.h>
#include <com/xuggle/xuggler/IError.h>

using namespace VS_CPP_NAMESPACE;
/**
 * Here to maintain BW-compatibility with Version 3.x of Xuggler;
 * can be removed when major version goes pass 3.
 */
extern "C" {
SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1seekKeyFrame_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jint jarg4);
SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1seekKeyFrame(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jint jarg4)
{
  return Java_com_xuggle_xuggler_XugglerJNI_IContainer_1seekKeyFrame_1_1SWIG_10(jenv, jcls, jarg1, jarg1_, jarg2, jarg3, jarg4);
}
}


extern "C" {

SWIGEXPORT void JNICALL
Java_com_xuggle_xuggler_Xuggler_init(JNIEnv *env, jclass)
{
  JavaVM* vm=0;
  if (!com::xuggle::ferry::JNIHelper::sGetVM()) {
    env->GetJavaVM(&vm);
    com::xuggle::ferry::JNIHelper::sSetVM(vm);
  }
}

}


// <<<<<<<<<<<<<<<<<<<<<<<<<<<
// Xuggler.i: End generated code



/**
 * Here to maintain BW-compatibility with Version 3.x of Xuggler;
 * can be removed when major version goes past 3.
 */
extern "C" {
SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1setData_1internal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_);
SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1setData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_)
{
  return Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1setData_1internal(jenv, jcls, jarg1, jarg1_, jarg2, jarg2_);
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1getData_1internal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_);
SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1getData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_)
{
  return Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1getData_1internal(jenv, jcls, jarg1, jarg1_);
}
}

SWIGINTERN com::xuggle::xuggler::IPacket *com_xuggle_xuggler_IMediaDataWrapper_getPacket(com::xuggle::xuggler::IMediaDataWrapper *self){
      IMediaData* data = self->get();
      IPacket* retval = dynamic_cast<IPacket*>(data);
      if (data && !retval) data->release();
      return retval;
    }
SWIGINTERN com::xuggle::xuggler::IAudioSamples *com_xuggle_xuggler_IMediaDataWrapper_getAudioSamples(com::xuggle::xuggler::IMediaDataWrapper *self){
      IMediaData* data = self->get();
      IAudioSamples* retval = dynamic_cast<IAudioSamples*>(data);
      if (data && !retval) data->release();
      return retval;
    }
SWIGINTERN com::xuggle::xuggler::IVideoPicture *com_xuggle_xuggler_IMediaDataWrapper_getVideoPicture(com::xuggle::xuggler::IMediaDataWrapper *self){
      IMediaData* data = self->get();
      IVideoPicture* retval = dynamic_cast<IVideoPicture*>(data);
      if (data && !retval) data->release();
      return retval;
    }
SWIGINTERN com::xuggle::xuggler::IMediaDataWrapper *com_xuggle_xuggler_IMediaDataWrapper_getMediaDataWrapper(com::xuggle::xuggler::IMediaDataWrapper *self){    
      IMediaData* data = self->get();
      IMediaDataWrapper* retval = dynamic_cast<IMediaDataWrapper*>(data);
      if (data && !retval) data->release();
      return retval;
    }
SWIGINTERN com::xuggle::xuggler::IPacket *com_xuggle_xuggler_IMediaDataWrapper_unwrapPacket(com::xuggle::xuggler::IMediaDataWrapper *self){
      IMediaData* data = self->unwrap();
      IPacket* retval = dynamic_cast<IPacket*>(data);
      if (data && !retval) data->release();
      return retval;
    }
SWIGINTERN com::xuggle::xuggler::IAudioSamples *com_xuggle_xuggler_IMediaDataWrapper_unwrapAudioSamples(com::xuggle::xuggler::IMediaDataWrapper *self){
      IMediaData* data = self->unwrap();
      IAudioSamples* retval = dynamic_cast<IAudioSamples*>(data);
      if (data && !retval) data->release();
      return retval;
    }
SWIGINTERN com::xuggle::xuggler::IVideoPicture *com_xuggle_xuggler_IMediaDataWrapper_unwrapVideoPicture(com::xuggle::xuggler::IMediaDataWrapper *self){
      IMediaData* data = self->unwrap();
      IVideoPicture* retval = dynamic_cast<IVideoPicture*>(data);
      if (data && !retval) data->release();
      return retval;
    }
SWIGINTERN com::xuggle::xuggler::IMediaDataWrapper *com_xuggle_xuggler_IMediaDataWrapper_unwrapMediaDataWrapper(com::xuggle::xuggler::IMediaDataWrapper *self){    
      IMediaData* data = self->unwrap();
      IMediaDataWrapper* retval = dynamic_cast<IMediaDataWrapper*>(data);
      if (data && !retval) data->release();
      return retval;
    }

#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1PROPERTY_1CONST_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty::Type result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IProperty::Type)com::xuggle::xuggler::IProperty::PROPERTY_CONST;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1PROPERTY_1UNKNOWN_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty::Type result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IProperty::Type)com::xuggle::xuggler::IProperty::PROPERTY_UNKNOWN;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1FLAG_1ENCODING_1PARAM_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IProperty::Flags)com::xuggle::xuggler::IProperty::FLAG_ENCODING_PARAM;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1FLAG_1DECODING_1PARAM_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IProperty::Flags)com::xuggle::xuggler::IProperty::FLAG_DECODING_PARAM;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1FLAG_1METADATA_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IProperty::Flags)com::xuggle::xuggler::IProperty::FLAG_METADATA;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1FLAG_1AUDIO_1PARAM_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IProperty::Flags)com::xuggle::xuggler::IProperty::FLAG_AUDIO_PARAM;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1FLAG_1VIDEO_1PARAM_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IProperty::Flags)com::xuggle::xuggler::IProperty::FLAG_VIDEO_PARAM;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1FLAG_1SUBTITLE_1PARAM_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IProperty::Flags)com::xuggle::xuggler::IProperty::FLAG_SUBTITLE_PARAM;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1PROPERTY_1SEARCH_1DEFAULT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty::Search result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IProperty::Search)com::xuggle::xuggler::IProperty::PROPERTY_SEARCH_DEFAULT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1PROPERTY_1SEARCH_1CHILDREN_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty::Search result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IProperty::Search)com::xuggle::xuggler::IProperty::PROPERTY_SEARCH_CHILDREN;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1getName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IProperty *arg1 = (com::xuggle::xuggler::IProperty *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IProperty **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getName();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1getHelp(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IProperty *arg1 = (com::xuggle::xuggler::IProperty *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IProperty **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getHelp();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1getUnit(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IProperty *arg1 = (com::xuggle::xuggler::IProperty *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IProperty **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getUnit();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1getType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty *arg1 = (com::xuggle::xuggler::IProperty *) 0 ;
  com::xuggle::xuggler::IProperty::Type result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IProperty **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IProperty::Type)(arg1)->getType();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1getFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty *arg1 = (com::xuggle::xuggler::IProperty *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IProperty **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getFlags();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1getDefault(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IProperty *arg1 = (com::xuggle::xuggler::IProperty *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IProperty **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getDefault();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1getDefaultAsDouble(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  com::xuggle::xuggler::IProperty *arg1 = (com::xuggle::xuggler::IProperty *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IProperty **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (double)(arg1)->getDefaultAsDouble();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1getNumFlagSettings(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IProperty *arg1 = (com::xuggle::xuggler::IProperty *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IProperty **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumFlagSettings();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1getFlagConstant_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IProperty *arg1 = (com::xuggle::xuggler::IProperty *) 0 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IProperty *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IProperty **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IProperty *)(arg1)->getFlagConstant(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IProperty **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IProperty_1getFlagConstant_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IProperty *arg1 = (com::xuggle::xuggler::IProperty *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IProperty *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IProperty **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IProperty *)(arg1)->getFlagConstant((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IProperty **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPixelFormat_1NONE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPixelFormat::Type result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IPixelFormat::Type)com::xuggle::xuggler::IPixelFormat::NONE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPixelFormat_1RGBA64BE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPixelFormat::Type result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IPixelFormat::Type)com::xuggle::xuggler::IPixelFormat::RGBA64BE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPixelFormat_1ZRGB_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPixelFormat::Type result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IPixelFormat::Type)com::xuggle::xuggler::IPixelFormat::ZRGB;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPixelFormat_1YUV_1Y_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPixelFormat::YUVColorComponent result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IPixelFormat::YUVColorComponent)com::xuggle::xuggler::IPixelFormat::YUV_Y;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPixelFormat_1YUV_1U_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPixelFormat::YUVColorComponent result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IPixelFormat::YUVColorComponent)com::xuggle::xuggler::IPixelFormat::YUV_U;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPixelFormat_1YUV_1V_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPixelFormat::YUVColorComponent result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IPixelFormat::YUVColorComponent)com::xuggle::xuggler::IPixelFormat::YUV_V;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jshort JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPixelFormat_1getYUV420PPixel(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jint jarg4) {
  jshort jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int arg2 ;
  int arg3 ;
  com::xuggle::xuggler::IPixelFormat::YUVColorComponent arg4 ;
  unsigned char result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (com::xuggle::xuggler::IPixelFormat::YUVColorComponent)jarg4; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (unsigned char)com::xuggle::xuggler::IPixelFormat::getYUV420PPixel(arg1,arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jshort)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPixelFormat_1setYUV420PPixel(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jint jarg4, jshort jarg5) {
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int arg2 ;
  int arg3 ;
  com::xuggle::xuggler::IPixelFormat::YUVColorComponent arg4 ;
  unsigned char arg5 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (com::xuggle::xuggler::IPixelFormat::YUVColorComponent)jarg4; 
  arg5 = (unsigned char)jarg5; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      com::xuggle::xuggler::IPixelFormat::setYUV420PPixel(arg1,arg2,arg3,arg4,arg5);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPixelFormat_1getYUV420PPixelOffset(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jint jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int arg2 ;
  int arg3 ;
  com::xuggle::xuggler::IPixelFormat::YUVColorComponent arg4 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (com::xuggle::xuggler::IPixelFormat::YUVColorComponent)jarg4; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)com::xuggle::xuggler::IPixelFormat::getYUV420PPixelOffset(arg1,arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1getNumerator(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumerator();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1getDenominator(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getDenominator();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1copy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->copy();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1compareTo(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->compareTo(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1sCompareTo(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::IRational::sCompareTo(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1getDouble(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (double)(arg1)->getDouble();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1reduce(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3, jlong jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  int64_t arg4 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  arg3 = (int64_t)jarg3; 
  arg4 = (int64_t)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->reduce(arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1sReduce(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3, jlong jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  int64_t arg4 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  arg3 = (int64_t)jarg3; 
  arg4 = (int64_t)jarg4; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::IRational::sReduce(arg1,arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1multiply(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->multiply(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1sMultiply(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)com::xuggle::xuggler::IRational::sMultiply(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1divide(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->divide(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1sDivide(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)com::xuggle::xuggler::IRational::sDivide(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1subtract(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->subtract(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1sSubtract(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)com::xuggle::xuggler::IRational::sSubtract(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1add(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->add(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1sAdd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)com::xuggle::xuggler::IRational::sAdd(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1rescale_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3, jobject jarg3_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  int64_t arg2 ;
  com::xuggle::xuggler::IRational *arg3 = (com::xuggle::xuggler::IRational *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  arg3 = *(com::xuggle::xuggler::IRational **)&jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->rescale(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1sRescale_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
  jlong jresult = 0 ;
  int64_t arg1 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg3 = (com::xuggle::xuggler::IRational *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = (int64_t)jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IRational **)&jarg3; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)com::xuggle::xuggler::IRational::sRescale(arg1,arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1make_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)com::xuggle::xuggler::IRational::make();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1make_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jdouble jarg1) {
  jlong jresult = 0 ;
  double arg1 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (double)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)com::xuggle::xuggler::IRational::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1make_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)com::xuggle::xuggler::IRational::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1make_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2) {
  jlong jresult = 0 ;
  int32_t arg1 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  arg2 = (int32_t)jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)com::xuggle::xuggler::IRational::make(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1ROUND_1ZERO_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational::Rounding result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IRational::Rounding)com::xuggle::xuggler::IRational::ROUND_ZERO;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1ROUND_1INF_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational::Rounding result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IRational::Rounding)com::xuggle::xuggler::IRational::ROUND_INF;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1ROUND_1DOWN_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational::Rounding result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IRational::Rounding)com::xuggle::xuggler::IRational::ROUND_DOWN;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1ROUND_1UP_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational::Rounding result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IRational::Rounding)com::xuggle::xuggler::IRational::ROUND_UP;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1ROUND_1NEAR_1INF_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IRational::Rounding result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IRational::Rounding)com::xuggle::xuggler::IRational::ROUND_NEAR_INF;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1rescale_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3, jobject jarg3_, jint jarg4) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  int64_t arg2 ;
  com::xuggle::xuggler::IRational *arg3 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational::Rounding arg4 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  arg3 = *(com::xuggle::xuggler::IRational **)&jarg3; 
  arg4 = (com::xuggle::xuggler::IRational::Rounding)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->rescale(arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1sRescale_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jint jarg4) {
  jlong jresult = 0 ;
  int64_t arg1 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational *arg3 = (com::xuggle::xuggler::IRational *) 0 ;
  com::xuggle::xuggler::IRational::Rounding arg4 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = (int64_t)jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IRational **)&jarg3; 
  arg4 = (com::xuggle::xuggler::IRational::Rounding)jarg4; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)com::xuggle::xuggler::IRational::sRescale(arg1,arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1rescale_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jint jarg2, jint jarg3, jint jarg4, jint jarg5, jint jarg6) {
  jlong jresult = 0 ;
  int64_t arg1 ;
  int32_t arg2 ;
  int32_t arg3 ;
  int32_t arg4 ;
  int32_t arg5 ;
  com::xuggle::xuggler::IRational::Rounding arg6 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int64_t)jarg1; 
  arg2 = (int32_t)jarg2; 
  arg3 = (int32_t)jarg3; 
  arg4 = (int32_t)jarg4; 
  arg5 = (int32_t)jarg5; 
  arg6 = (com::xuggle::xuggler::IRational::Rounding)jarg6; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)com::xuggle::xuggler::IRational::rescale(arg1,arg2,arg3,arg4,arg5,arg6);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1setNumerator(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setNumerator(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1setDenominator(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setDenominator(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1setValue(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  double arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  arg2 = (double)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setValue(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jdouble JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1getValue(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (double)(arg1)->getValue();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1isFinalized(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isFinalized();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IRational_1init(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  com::xuggle::xuggler::IRational *arg1 = (com::xuggle::xuggler::IRational *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IRational **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->init();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ITimeValue_1make_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jint jarg2) {
  jlong jresult = 0 ;
  int64_t arg1 ;
  com::xuggle::xuggler::ITimeValue::Unit arg2 ;
  com::xuggle::xuggler::ITimeValue *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int64_t)jarg1; 
  arg2 = (com::xuggle::xuggler::ITimeValue::Unit)jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ITimeValue *)com::xuggle::xuggler::ITimeValue::make(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ITimeValue **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ITimeValue_1make_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::ITimeValue *arg1 = (com::xuggle::xuggler::ITimeValue *) 0 ;
  com::xuggle::xuggler::ITimeValue *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ITimeValue **)&jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ITimeValue *)com::xuggle::xuggler::ITimeValue::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ITimeValue **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ITimeValue_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::ITimeValue *arg1 = (com::xuggle::xuggler::ITimeValue *) 0 ;
  com::xuggle::xuggler::ITimeValue::Unit arg2 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ITimeValue **)&jarg1; 
  arg2 = (com::xuggle::xuggler::ITimeValue::Unit)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->get(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ITimeValue_1compareTo(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ITimeValue *arg1 = (com::xuggle::xuggler::ITimeValue *) 0 ;
  com::xuggle::xuggler::ITimeValue *arg2 = (com::xuggle::xuggler::ITimeValue *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::ITimeValue **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::ITimeValue **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->compareTo(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ITimeValue_1compare_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ITimeValue *arg1 = (com::xuggle::xuggler::ITimeValue *) 0 ;
  com::xuggle::xuggler::ITimeValue *arg2 = (com::xuggle::xuggler::ITimeValue *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::ITimeValue **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::ITimeValue **)&jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::ITimeValue::compare(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ITimeValue_1compare_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
  jint jresult = 0 ;
  int64_t arg1 ;
  int64_t arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int64_t)jarg1; 
  arg2 = (int64_t)jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::ITimeValue::compare(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMetaData_1METADATA_1NONE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IMetaData::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IMetaData::Flags)com::xuggle::xuggler::IMetaData::METADATA_NONE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMetaData_1METADATA_1MATCH_1CASE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IMetaData::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IMetaData::Flags)com::xuggle::xuggler::IMetaData::METADATA_MATCH_CASE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMetaData_1METADATA_1DONT_1OVERWRITE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IMetaData::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IMetaData::Flags)com::xuggle::xuggler::IMetaData::METADATA_DONT_OVERWRITE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMetaData_1META_1DATA_1APPEND_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IMetaData::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IMetaData::Flags)com::xuggle::xuggler::IMetaData::META_DATA_APPEND;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMetaData_1getNumKeys(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IMetaData *arg1 = (com::xuggle::xuggler::IMetaData *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMetaData **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumKeys();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMetaData_1getKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IMetaData *arg1 = (com::xuggle::xuggler::IMetaData *) 0 ;
  int32_t arg2 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMetaData **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getKey(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMetaData_1getValue(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IMetaData *arg1 = (com::xuggle::xuggler::IMetaData *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IMetaData::Flags arg3 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMetaData **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (com::xuggle::xuggler::IMetaData::Flags)jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getValue((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMetaData_1setValue_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IMetaData *arg1 = (com::xuggle::xuggler::IMetaData *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMetaData **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setValue((char const *)arg2,(char const *)arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMetaData_1make(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMetaData *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IMetaData *)com::xuggle::xuggler::IMetaData::make();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IMetaData **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMetaData_1setValue_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jint jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IMetaData *arg1 = (com::xuggle::xuggler::IMetaData *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  com::xuggle::xuggler::IMetaData::Flags arg4 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMetaData **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = (com::xuggle::xuggler::IMetaData::Flags)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setValue((char const *)arg2,(char const *)arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1getTimeStamp(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaData *arg1 = (com::xuggle::xuggler::IMediaData *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaData **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getTimeStamp();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1setTimeStamp(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  com::xuggle::xuggler::IMediaData *arg1 = (com::xuggle::xuggler::IMediaData *) 0 ;
  int64_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaData **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setTimeStamp(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1getTimeBase(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaData *arg1 = (com::xuggle::xuggler::IMediaData *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaData **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->getTimeBase();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1setTimeBase(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  com::xuggle::xuggler::IMediaData *arg1 = (com::xuggle::xuggler::IMediaData *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IMediaData **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setTimeBase(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1getData_1internal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaData *arg1 = (com::xuggle::xuggler::IMediaData *) 0 ;
  com::xuggle::ferry::IBuffer *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaData **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::ferry::IBuffer *)(arg1)->getData();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::ferry::IBuffer **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1getSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IMediaData *arg1 = (com::xuggle::xuggler::IMediaData *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaData **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1isKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IMediaData *arg1 = (com::xuggle::xuggler::IMediaData *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaData **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isKey();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaData_1setData_1internal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  com::xuggle::xuggler::IMediaData *arg1 = (com::xuggle::xuggler::IMediaData *) 0 ;
  com::xuggle::ferry::IBuffer *arg2 = (com::xuggle::ferry::IBuffer *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IMediaData **)&jarg1; 
  arg2 = *(com::xuggle::ferry::IBuffer **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setData(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1reset(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->reset();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1isComplete(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isComplete();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1getPts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getPts();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1setPts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int64_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setPts(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1getDts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getDts();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1setDts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int64_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setDts(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1getSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1getMaxSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getMaxSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1getStreamIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getStreamIndex();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1getFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getFlags();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1isKeyPacket(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isKeyPacket();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1getDuration(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getDuration();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1getPosition(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getPosition();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1allocateNewPayload(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->allocateNewPayload(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1make_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IPacket *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPacket *)com::xuggle::xuggler::IPacket::make();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IPacket **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1make_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::ferry::IBuffer *arg1 = (com::xuggle::ferry::IBuffer *) 0 ;
  com::xuggle::xuggler::IPacket *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::ferry::IBuffer **)&jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPacket *)com::xuggle::xuggler::IPacket::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IPacket **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1setKeyPacket(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setKeyPacket(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1setFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setFlags(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1setComplete(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2, jint jarg3) {
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  bool arg2 ;
  int32_t arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  arg3 = (int32_t)jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setComplete(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1setStreamIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setStreamIndex(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1setDuration(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int64_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setDuration(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1setPosition(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int64_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setPosition(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1getConvergenceDuration(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getConvergenceDuration();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1setConvergenceDuration(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  int64_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setConvergenceDuration(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1make_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IPacket *arg1 = (com::xuggle::xuggler::IPacket *) 0 ;
  bool arg2 ;
  com::xuggle::xuggler::IPacket *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IPacket **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPacket *)com::xuggle::xuggler::IPacket::make(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IPacket **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IPacket_1make_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int32_t arg1 ;
  com::xuggle::xuggler::IPacket *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPacket *)com::xuggle::xuggler::IPacket::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IPacket **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1FMT_1NONE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::Format result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::Format)com::xuggle::xuggler::IAudioSamples::FMT_NONE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1isComplete(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isComplete();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getSampleRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getSampleRate();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getChannels(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getChannels();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getSampleBitDepth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  uint32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (uint32_t)(arg1)->getSampleBitDepth();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  com::xuggle::xuggler::IAudioSamples::Format result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioSamples::Format)(arg1)->getFormat();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getNumSamples(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  uint32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (uint32_t)(arg1)->getNumSamples();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getMaxBufferSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  uint32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (uint32_t)(arg1)->getMaxBufferSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getMaxSamples(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  uint32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (uint32_t)(arg1)->getMaxSamples();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getSampleSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  uint32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (uint32_t)(arg1)->getSampleSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getPts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getPts();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1setPts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  int64_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setPts(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getNextPts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getNextPts();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1setComplete(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2, jlong jarg3, jint jarg4, jint jarg5, jint jarg6, jlong jarg7) {
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  bool arg2 ;
  uint32_t arg3 ;
  int32_t arg4 ;
  int32_t arg5 ;
  com::xuggle::xuggler::IAudioSamples::Format arg6 ;
  int64_t arg7 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  arg3 = (uint32_t)jarg3; 
  arg4 = (int32_t)jarg4; 
  arg5 = (int32_t)jarg5; 
  arg6 = (com::xuggle::xuggler::IAudioSamples::Format)jarg6; 
  arg7 = (int64_t)jarg7; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setComplete(arg2,arg3,arg4,arg5,arg6,arg7);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1setSample(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jint jarg3, jint jarg4, jint jarg5) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  uint32_t arg2 ;
  int32_t arg3 ;
  com::xuggle::xuggler::IAudioSamples::Format arg4 ;
  int32_t arg5 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  arg2 = (uint32_t)jarg2; 
  arg3 = (int32_t)jarg3; 
  arg4 = (com::xuggle::xuggler::IAudioSamples::Format)jarg4; 
  arg5 = (int32_t)jarg5; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setSample(arg2,arg3,arg4,arg5);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1getSample(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jint jarg3, jint jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples *arg1 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  uint32_t arg2 ;
  int32_t arg3 ;
  com::xuggle::xuggler::IAudioSamples::Format arg4 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioSamples **)&jarg1; 
  arg2 = (uint32_t)jarg2; 
  arg3 = (int32_t)jarg3; 
  arg4 = (com::xuggle::xuggler::IAudioSamples::Format)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getSample(arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1findSampleBitDepth(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::Format arg1 ;
  uint32_t result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (com::xuggle::xuggler::IAudioSamples::Format)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (uint32_t)com::xuggle::xuggler::IAudioSamples::findSampleBitDepth(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1make_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
  jlong jresult = 0 ;
  uint32_t arg1 ;
  uint32_t arg2 ;
  com::xuggle::xuggler::IAudioSamples *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (uint32_t)jarg1; 
  arg2 = (uint32_t)jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioSamples *)com::xuggle::xuggler::IAudioSamples::make(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IAudioSamples **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1samplesToDefaultPts(JNIEnv *jenv, jclass jcls, jlong jarg1, jint jarg2) {
  jlong jresult = 0 ;
  int64_t arg1 ;
  int arg2 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int64_t)jarg1; 
  arg2 = (int)jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)com::xuggle::xuggler::IAudioSamples::samplesToDefaultPts(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1defaultPtsToSamples(JNIEnv *jenv, jclass jcls, jlong jarg1, jint jarg2) {
  jlong jresult = 0 ;
  int64_t arg1 ;
  int arg2 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int64_t)jarg1; 
  arg2 = (int)jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)com::xuggle::xuggler::IAudioSamples::defaultPtsToSamples(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1FRONT_1LEFT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_FRONT_LEFT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1FRONT_1RIGHT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_FRONT_RIGHT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1FRONT_1CENTER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_FRONT_CENTER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LOW_1FREQUENCY_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LOW_FREQUENCY;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1BACK_1LEFT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_BACK_LEFT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1BACK_1RIGHT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_BACK_RIGHT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1FRONT_1LEFT_1OF_1CENTER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_FRONT_LEFT_OF_CENTER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1FRONT_1RIGHT_1OF_1CENTER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_FRONT_RIGHT_OF_CENTER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1BACK_1CENTER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_BACK_CENTER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1SIDE_1LEFT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_SIDE_LEFT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1SIDE_1RIGHT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_SIDE_RIGHT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1TOP_1CENTER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_TOP_CENTER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1TOP_1FRONT_1LEFT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_TOP_FRONT_LEFT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1TOP_1FRONT_1CENTER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_TOP_FRONT_CENTER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1TOP_1FRONT_1RIGHT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_TOP_FRONT_RIGHT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1TOP_1BACK_1LEFT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_TOP_BACK_LEFT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1TOP_1BACK_1CENTER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_TOP_BACK_CENTER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1TOP_1BACK_1RIGHT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_TOP_BACK_RIGHT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1STEREO_1LEFT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_STEREO_LEFT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1STEREO_1RIGHT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_STEREO_RIGHT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_1MONO_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_MONO;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_1STEREO_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_STEREO;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_12_11_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_2_1;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_1SURROUND_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_SURROUND;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_14POINT0_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_4POINT0;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_12_12_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_2_2;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_1QUAD_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_QUAD;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_15POINT0_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_5POINT0;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_15POINT1_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_5POINT1;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_15POINT0_1BACK_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_5POINT0_BACK;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_15POINT1_1BACK_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_5POINT1_BACK;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_17POINT1_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_7POINT1;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_17POINT1_1WIDE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_7POINT1_WIDE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1CH_1LAYOUT_1STEREO_1DOWNMIX_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioSamples::ChannelLayout result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IAudioSamples::ChannelLayout)com::xuggle::xuggler::IAudioSamples::CH_LAYOUT_STEREO_DOWNMIX;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1make_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3) {
  jlong jresult = 0 ;
  com::xuggle::ferry::IBuffer *arg1 = (com::xuggle::ferry::IBuffer *) 0 ;
  int arg2 ;
  com::xuggle::xuggler::IAudioSamples::Format arg3 ;
  com::xuggle::xuggler::IAudioSamples *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::ferry::IBuffer **)&jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (com::xuggle::xuggler::IAudioSamples::Format)jarg3; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioSamples *)com::xuggle::xuggler::IAudioSamples::make(arg1,arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IAudioSamples **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioSamples_1make_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2, jint jarg3) {
  jlong jresult = 0 ;
  uint32_t arg1 ;
  uint32_t arg2 ;
  com::xuggle::xuggler::IAudioSamples::Format arg3 ;
  com::xuggle::xuggler::IAudioSamples *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (uint32_t)jarg1; 
  arg2 = (uint32_t)jarg2; 
  arg3 = (com::xuggle::xuggler::IAudioSamples::Format)jarg3; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioSamples *)com::xuggle::xuggler::IAudioSamples::make(arg1,arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IAudioSamples **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1isKeyFrame(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isKeyFrame();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1setKeyFrame(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setKeyFrame(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1isComplete(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isComplete();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1getSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1getWidth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getWidth();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1getHeight(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getHeight();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1getPixelType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  com::xuggle::xuggler::IPixelFormat::Type result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPixelFormat::Type)(arg1)->getPixelType();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1getPts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getPts();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1setPts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int64_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setPts(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1getQuality(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getQuality();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1setQuality(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  arg2 = (int)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setQuality(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1getDataLineSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  arg2 = (int)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getDataLineSize(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1setComplete(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2, jint jarg3, jint jarg4, jint jarg5, jlong jarg6) {
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  bool arg2 ;
  com::xuggle::xuggler::IPixelFormat::Type arg3 ;
  int arg4 ;
  int arg5 ;
  int64_t arg6 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  arg3 = (com::xuggle::xuggler::IPixelFormat::Type)jarg3; 
  arg4 = (int)jarg4; 
  arg5 = (int)jarg5; 
  arg6 = (int64_t)jarg6; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setComplete(arg2,arg3,arg4,arg5,arg6);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1copy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  com::xuggle::xuggler::IVideoPicture *arg2 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IVideoPicture **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->copy(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1make_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jint jarg3) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IPixelFormat::Type arg1 ;
  int arg2 ;
  int arg3 ;
  com::xuggle::xuggler::IVideoPicture *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (com::xuggle::xuggler::IPixelFormat::Type)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IVideoPicture *)com::xuggle::xuggler::IVideoPicture::make(arg1,arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IVideoPicture **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1make_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  com::xuggle::xuggler::IVideoPicture *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IVideoPicture *)com::xuggle::xuggler::IVideoPicture::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IVideoPicture **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1DEFAULT_1TYPE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture::PictType result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IVideoPicture::PictType)com::xuggle::xuggler::IVideoPicture::DEFAULT_TYPE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1I_1TYPE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture::PictType result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IVideoPicture::PictType)com::xuggle::xuggler::IVideoPicture::I_TYPE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1P_1TYPE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture::PictType result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IVideoPicture::PictType)com::xuggle::xuggler::IVideoPicture::P_TYPE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1B_1TYPE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture::PictType result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IVideoPicture::PictType)com::xuggle::xuggler::IVideoPicture::B_TYPE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1S_1TYPE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture::PictType result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IVideoPicture::PictType)com::xuggle::xuggler::IVideoPicture::S_TYPE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1SI_1TYPE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture::PictType result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IVideoPicture::PictType)com::xuggle::xuggler::IVideoPicture::SI_TYPE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1SP_1TYPE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture::PictType result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IVideoPicture::PictType)com::xuggle::xuggler::IVideoPicture::SP_TYPE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1BI_1TYPE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture::PictType result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IVideoPicture::PictType)com::xuggle::xuggler::IVideoPicture::BI_TYPE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1getPictureType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  com::xuggle::xuggler::IVideoPicture::PictType result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IVideoPicture::PictType)(arg1)->getPictureType();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1setPictureType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IVideoPicture *arg1 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  com::xuggle::xuggler::IVideoPicture::PictType arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoPicture **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IVideoPicture::PictType)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setPictureType(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoPicture_1make_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jint jarg4) {
  jlong jresult = 0 ;
  com::xuggle::ferry::IBuffer *arg1 = (com::xuggle::ferry::IBuffer *) 0 ;
  com::xuggle::xuggler::IPixelFormat::Type arg2 ;
  int arg3 ;
  int arg4 ;
  com::xuggle::xuggler::IVideoPicture *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::ferry::IBuffer **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IPixelFormat::Type)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (int)jarg4; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IVideoPicture *)com::xuggle::xuggler::IVideoPicture::make(arg1,arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IVideoPicture **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_LIBAVCODEC_1VERSION_1MAJOR_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) 54;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1Y41P_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_Y41P;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1ESCAPE130_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_ESCAPE130;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1EXR_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_EXR;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1AVRP_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_AVRP;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1G2M_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_G2M;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1AYUV_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_AYUV;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1V308_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_V308;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1V408_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_V408;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1YUV4_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_YUV4;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1FIRST_1AUDIO_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_FIRST_AUDIO;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1PCM_1S16LE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_PCM_S16LE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1ADPCM_1IMA_1QT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_ADPCM_IMA_QT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1AMR_1NB_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_AMR_NB;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1RA_1144_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_RA_144;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1ROQ_1DPCM_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_ROQ_DPCM;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1MP2_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_MP2;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1FFWAVESYNTH_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_FFWAVESYNTH;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_18SVX_1RAW_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_8SVX_RAW;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1SONIC_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_SONIC;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1SONIC_1LS_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_SONIC_LS;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1FIRST_1SUBTITLE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_FIRST_SUBTITLE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1DVD_1SUBTITLE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_DVD_SUBTITLE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1MICRODVD_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_MICRODVD;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1EIA_1608_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_EIA_608;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1FIRST_1UNKNOWN_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_FIRST_UNKNOWN;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1TTF_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_TTF;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1BINTEXT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_BINTEXT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1XBIN_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_XBIN;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1IDF_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_IDF;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1PROBE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_PROBE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1MPEG2TS_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_MPEG2TS;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1MPEG4SYSTEMS_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_MPEG4SYSTEMS;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1ID_1FFMETADATA_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::ID)com::xuggle::xuggler::ICodec::CODEC_ID_FFMETADATA;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CODEC_1TYPE_1UNKNOWN_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::Type result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::Type)com::xuggle::xuggler::ICodec::CODEC_TYPE_UNKNOWN;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getName();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getIDAsInt(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getIDAsInt();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getID(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec::ID)(arg1)->getID();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  com::xuggle::xuggler::ICodec::Type result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec::Type)(arg1)->getType();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1canDecode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->canDecode();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1canEncode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->canEncode();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1findEncodingCodec(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID arg1 ;
  com::xuggle::xuggler::ICodec *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (com::xuggle::xuggler::ICodec::ID)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec *)com::xuggle::xuggler::ICodec::findEncodingCodec(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ICodec **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1findEncodingCodecByIntID(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int arg1 ;
  com::xuggle::xuggler::ICodec *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec *)com::xuggle::xuggler::ICodec::findEncodingCodecByIntID(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ICodec **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1findEncodingCodecByName(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  char *arg1 = (char *) 0 ;
  com::xuggle::xuggler::ICodec *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1) return 0;
  }
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec *)com::xuggle::xuggler::ICodec::findEncodingCodecByName((char const *)arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ICodec **)&jresult = result; 
  if (arg1) jenv->ReleaseStringUTFChars(jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1findDecodingCodec(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::ICodec::ID arg1 ;
  com::xuggle::xuggler::ICodec *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (com::xuggle::xuggler::ICodec::ID)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec *)com::xuggle::xuggler::ICodec::findDecodingCodec(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ICodec **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1findDecodingCodecByIntID(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int arg1 ;
  com::xuggle::xuggler::ICodec *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec *)com::xuggle::xuggler::ICodec::findDecodingCodecByIntID(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ICodec **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1findDecodingCodecByName(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  char *arg1 = (char *) 0 ;
  com::xuggle::xuggler::ICodec *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1) return 0;
  }
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec *)com::xuggle::xuggler::ICodec::findDecodingCodecByName((char const *)arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ICodec **)&jresult = result; 
  if (arg1) jenv->ReleaseStringUTFChars(jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1guessEncodingCodec(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jstring jarg4, jint jarg5) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  com::xuggle::xuggler::ICodec::Type arg5 ;
  com::xuggle::xuggler::ICodec *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  arg5 = (com::xuggle::xuggler::ICodec::Type)jarg5; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec *)com::xuggle::xuggler::ICodec::guessEncodingCodec(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ICodec **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getLongName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getLongName();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CAP_1DRAW_1HORIZ_1BAND_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::Capabilities result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::Capabilities)com::xuggle::xuggler::ICodec::CAP_DRAW_HORIZ_BAND;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CAP_1DR1_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::Capabilities result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::Capabilities)com::xuggle::xuggler::ICodec::CAP_DR1;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CAP_1PARSE_1ONLY_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::Capabilities result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::Capabilities)com::xuggle::xuggler::ICodec::CAP_PARSE_ONLY;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CAP_1TRUNCATED_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::Capabilities result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::Capabilities)com::xuggle::xuggler::ICodec::CAP_TRUNCATED;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CAP_1HWACCEL_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::Capabilities result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::Capabilities)com::xuggle::xuggler::ICodec::CAP_HWACCEL;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CAP_1DELAY_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::Capabilities result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::Capabilities)com::xuggle::xuggler::ICodec::CAP_DELAY;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CAP_1SMALL_1LAST_1FRAME_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::Capabilities result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::Capabilities)com::xuggle::xuggler::ICodec::CAP_SMALL_LAST_FRAME;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CAP_1HWACCEL_1VDPAU_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::Capabilities result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::Capabilities)com::xuggle::xuggler::ICodec::CAP_HWACCEL_VDPAU;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1CAP_1SUBFRAMES_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec::Capabilities result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::ICodec::Capabilities)com::xuggle::xuggler::ICodec::CAP_SUBFRAMES;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getCapabilities(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getCapabilities();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1hasCapability(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  com::xuggle::xuggler::ICodec::Capabilities arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  arg2 = (com::xuggle::xuggler::ICodec::Capabilities)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->hasCapability(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getNumInstalledCodecs(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::ICodec::getNumInstalledCodecs();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getInstalledCodec(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int32_t arg1 ;
  com::xuggle::xuggler::ICodec *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec *)com::xuggle::xuggler::ICodec::getInstalledCodec(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ICodec **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getNumSupportedVideoFrameRates(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumSupportedVideoFrameRates();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getSupportedVideoFrameRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->getSupportedVideoFrameRate(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getNumSupportedVideoPixelFormats(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumSupportedVideoPixelFormats();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getSupportedVideoPixelFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IPixelFormat::Type result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPixelFormat::Type)(arg1)->getSupportedVideoPixelFormat(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getNumSupportedAudioSampleRates(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumSupportedAudioSampleRates();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getSupportedAudioSampleRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getSupportedAudioSampleRate(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getNumSupportedAudioSampleFormats(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumSupportedAudioSampleFormats();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getSupportedAudioSampleFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IAudioSamples::Format result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioSamples::Format)(arg1)->getSupportedAudioSampleFormat(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getNumSupportedAudioChannelLayouts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumSupportedAudioChannelLayouts();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_ICodec_1getSupportedAudioChannelLayout(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::ICodec *arg1 = (com::xuggle::xuggler::ICodec *) 0 ;
  int32_t arg2 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::ICodec **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getSupportedAudioChannelLayout(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getOutputChannels(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getOutputChannels();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getOutputRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getOutputRate();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getInputChannels(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getInputChannels();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getInputRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getInputRate();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1resample(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jlong jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  com::xuggle::xuggler::IAudioSamples *arg2 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  com::xuggle::xuggler::IAudioSamples *arg3 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  unsigned int arg4 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IAudioSamples **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IAudioSamples **)&jarg3; 
  arg4 = (unsigned int)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->resample(arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1make_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jint jarg3, jint jarg4) {
  jlong jresult = 0 ;
  int32_t arg1 ;
  int32_t arg2 ;
  int32_t arg3 ;
  int32_t arg4 ;
  com::xuggle::xuggler::IAudioResampler *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  arg2 = (int32_t)jarg2; 
  arg3 = (int32_t)jarg3; 
  arg4 = (int32_t)jarg4; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioResampler *)com::xuggle::xuggler::IAudioResampler::make(arg1,arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IAudioResampler **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getOutputFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  com::xuggle::xuggler::IAudioSamples::Format result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioSamples::Format)(arg1)->getOutputFormat();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getInputFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  com::xuggle::xuggler::IAudioSamples::Format result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioSamples::Format)(arg1)->getInputFormat();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getFilterLen(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getFilterLen();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getLog2PhaseCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getLog2PhaseCount();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1isLinear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isLinear();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getCutoffFrequency(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (double)(arg1)->getCutoffFrequency();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1make_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jint jarg3, jint jarg4, jint jarg5, jint jarg6) {
  jlong jresult = 0 ;
  int32_t arg1 ;
  int32_t arg2 ;
  int32_t arg3 ;
  int32_t arg4 ;
  com::xuggle::xuggler::IAudioSamples::Format arg5 ;
  com::xuggle::xuggler::IAudioSamples::Format arg6 ;
  com::xuggle::xuggler::IAudioResampler *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  arg2 = (int32_t)jarg2; 
  arg3 = (int32_t)jarg3; 
  arg4 = (int32_t)jarg4; 
  arg5 = (com::xuggle::xuggler::IAudioSamples::Format)jarg5; 
  arg6 = (com::xuggle::xuggler::IAudioSamples::Format)jarg6; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioResampler *)com::xuggle::xuggler::IAudioResampler::make(arg1,arg2,arg3,arg4,arg5,arg6);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IAudioResampler **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1make_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jint jarg3, jint jarg4, jint jarg5, jint jarg6, jint jarg7, jint jarg8, jboolean jarg9, jdouble jarg10) {
  jlong jresult = 0 ;
  int32_t arg1 ;
  int32_t arg2 ;
  int32_t arg3 ;
  int32_t arg4 ;
  com::xuggle::xuggler::IAudioSamples::Format arg5 ;
  com::xuggle::xuggler::IAudioSamples::Format arg6 ;
  int32_t arg7 ;
  int32_t arg8 ;
  bool arg9 ;
  double arg10 ;
  com::xuggle::xuggler::IAudioResampler *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  arg2 = (int32_t)jarg2; 
  arg3 = (int32_t)jarg3; 
  arg4 = (int32_t)jarg4; 
  arg5 = (com::xuggle::xuggler::IAudioSamples::Format)jarg5; 
  arg6 = (com::xuggle::xuggler::IAudioSamples::Format)jarg6; 
  arg7 = (int32_t)jarg7; 
  arg8 = (int32_t)jarg8; 
  arg9 = jarg9 ? true : false; 
  arg10 = (double)jarg10; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioResampler *)com::xuggle::xuggler::IAudioResampler::make(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IAudioResampler **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getMinimumNumSamplesRequiredInOutputSamples_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  com::xuggle::xuggler::IAudioSamples *arg2 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IAudioSamples **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getMinimumNumSamplesRequiredInOutputSamples(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IAudioResampler_1getMinimumNumSamplesRequiredInOutputSamples_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IAudioResampler *arg1 = (com::xuggle::xuggler::IAudioResampler *) 0 ;
  int32_t arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IAudioResampler **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getMinimumNumSamplesRequiredInOutputSamples(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getInputWidth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getInputWidth();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getInputHeight(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getInputHeight();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getInputPixelFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  com::xuggle::xuggler::IPixelFormat::Type result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPixelFormat::Type)(arg1)->getInputPixelFormat();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getOutputWidth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getOutputWidth();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getOutputHeight(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getOutputHeight();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getOutputPixelFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  com::xuggle::xuggler::IPixelFormat::Type result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPixelFormat::Type)(arg1)->getOutputPixelFormat();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1resample(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  com::xuggle::xuggler::IVideoPicture *arg2 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  com::xuggle::xuggler::IVideoPicture *arg3 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IVideoPicture **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IVideoPicture **)&jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->resample(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getNumProperties(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumProperties();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getPropertyMetaData_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IProperty *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IProperty *)(arg1)->getPropertyMetaData(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IProperty **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getPropertyMetaData_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IProperty *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IProperty *)(arg1)->getPropertyMetaData((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IProperty **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1setProperty_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,(char const *)arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1setProperty_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jdouble jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (double)jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1setProperty_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  int64_t arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (int64_t)jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1setProperty_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jboolean jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = jarg3 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1setProperty_1_1SWIG_14(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3, jobject jarg3_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IRational *arg3 = (com::xuggle::xuggler::IRational *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = *(com::xuggle::xuggler::IRational **)&jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getPropertyAsString(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getPropertyAsString((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  free(result);
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getPropertyAsDouble(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jdouble jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (double)(arg1)->getPropertyAsDouble((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jdouble)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getPropertyAsLong(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getPropertyAsLong((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getPropertyAsRational(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->getPropertyAsRational((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1getPropertyAsBoolean(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->getPropertyAsBoolean((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1make(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jint jarg3, jint jarg4, jint jarg5, jint jarg6) {
  jlong jresult = 0 ;
  int32_t arg1 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IPixelFormat::Type arg3 ;
  int32_t arg4 ;
  int32_t arg5 ;
  com::xuggle::xuggler::IPixelFormat::Type arg6 ;
  com::xuggle::xuggler::IVideoResampler *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  arg2 = (int32_t)jarg2; 
  arg3 = (com::xuggle::xuggler::IPixelFormat::Type)jarg3; 
  arg4 = (int32_t)jarg4; 
  arg5 = (int32_t)jarg5; 
  arg6 = (com::xuggle::xuggler::IPixelFormat::Type)jarg6; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IVideoResampler *)com::xuggle::xuggler::IVideoResampler::make(arg1,arg2,arg3,arg4,arg5,arg6);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IVideoResampler **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1isSupported(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler::Feature arg1 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (com::xuggle::xuggler::IVideoResampler::Feature)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)com::xuggle::xuggler::IVideoResampler::isSupported(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IVideoResampler_1setProperty_1_1SWIG_15(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IVideoResampler *arg1 = (com::xuggle::xuggler::IVideoResampler *) 0 ;
  com::xuggle::xuggler::IMetaData *arg2 = (com::xuggle::xuggler::IMetaData *) 0 ;
  com::xuggle::xuggler::IMetaData *arg3 = (com::xuggle::xuggler::IMetaData *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IVideoResampler **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IMetaData **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IMetaData **)&jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1QSCALE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_QSCALE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_14MV_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_4MV;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1QPEL_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_QPEL;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1GMC_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_GMC;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1MV0_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_MV0;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1INPUT_1PRESERVED_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_INPUT_PRESERVED;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1PASS1_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_PASS1;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1PASS2_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_PASS2;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1GRAY_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_GRAY;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1EMU_1EDGE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_EMU_EDGE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1PSNR_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_PSNR;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1TRUNCATED_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_TRUNCATED;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1NORMALIZE_1AQP_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_NORMALIZE_AQP;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1INTERLACED_1DCT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_INTERLACED_DCT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1LOW_1DELAY_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_LOW_DELAY;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1GLOBAL_1HEADER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_GLOBAL_HEADER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1BITEXACT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_BITEXACT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1AC_1PRED_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_AC_PRED;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1CBP_1RD_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_CBP_RD;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1QP_1RD_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_QP_RD;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1LOOP_1FILTER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_LOOP_FILTER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1INTERLACED_1ME_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_INTERLACED_ME;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG_1CLOSED_1GOP_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG_CLOSED_GOP;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG2_1FAST_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG2_FAST;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG2_1STRICT_1GOP_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG2_STRICT_GOP;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG2_1NO_1OUTPUT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG2_NO_OUTPUT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG2_1LOCAL_1HEADER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG2_LOCAL_HEADER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG2_1SKIP_1RD_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG2_SKIP_RD;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG2_1CHUNKS_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG2_CHUNKS;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1FLAG2_1SHOW_1ALL_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::Flags)com::xuggle::xuggler::IStreamCoder::FLAG2_SHOW_ALL;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getDirection(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IStreamCoder::Direction result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStreamCoder::Direction)(arg1)->getDirection();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getStream(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IStream *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStream *)(arg1)->getStream();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStream **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getCodec(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::ICodec *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec *)(arg1)->getCodec();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::ICodec **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getCodecType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::ICodec::Type result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec::Type)(arg1)->getCodecType();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getCodecID(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec::ID)(arg1)->getCodecID();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setCodec_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::ICodec *arg2 = (com::xuggle::xuggler::ICodec *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::ICodec **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setCodec(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setCodec_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::ICodec::ID arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (com::xuggle::xuggler::ICodec::ID)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setCodec(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getBitRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getBitRate();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setBitRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setBitRate(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getBitRateTolerance(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getBitRateTolerance();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setBitRateTolerance(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setBitRateTolerance(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getHeight(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getHeight();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setHeight(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setHeight(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getWidth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getWidth();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setWidth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setWidth(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getTimeBase(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->getTimeBase();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setTimeBase(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setTimeBase(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getFrameRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->getFrameRate();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setFrameRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setFrameRate(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getNumPicturesInGroupOfPictures(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumPicturesInGroupOfPictures();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setNumPicturesInGroupOfPictures(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setNumPicturesInGroupOfPictures(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getPixelType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IPixelFormat::Type result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPixelFormat::Type)(arg1)->getPixelType();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setPixelType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IPixelFormat::Type arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IPixelFormat::Type)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setPixelType(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getSampleRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getSampleRate();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setSampleRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setSampleRate(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getSampleFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IAudioSamples::Format result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioSamples::Format)(arg1)->getSampleFormat();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setSampleFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IAudioSamples::Format arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IAudioSamples::Format)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setSampleFormat(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getChannels(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getChannels();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setChannels(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setChannels(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getAudioFrameSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getAudioFrameSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getGlobalQuality(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getGlobalQuality();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setGlobalQuality(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setGlobalQuality(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getFlags();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setFlags(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getFlag(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IStreamCoder::Flags)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->getFlag(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setFlag(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jboolean jarg3) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IStreamCoder::Flags arg2 ;
  bool arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IStreamCoder::Flags)jarg2; 
  arg3 = jarg3 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setFlag(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getNextPredictedPts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getNextPredictedPts();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1open_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->open();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1close(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->close();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1decodeAudio(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jint jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IAudioSamples *arg2 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  com::xuggle::xuggler::IPacket *arg3 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t arg4 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IAudioSamples **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IPacket **)&jarg3; 
  arg4 = (int32_t)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->decodeAudio(arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1decodeVideo(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jint jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IVideoPicture *arg2 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  com::xuggle::xuggler::IPacket *arg3 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t arg4 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IVideoPicture **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IPacket **)&jarg3; 
  arg4 = (int32_t)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->decodeVideo(arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1encodeVideo(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jint jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IPacket *arg2 = (com::xuggle::xuggler::IPacket *) 0 ;
  com::xuggle::xuggler::IVideoPicture *arg3 = (com::xuggle::xuggler::IVideoPicture *) 0 ;
  int32_t arg4 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IPacket **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IVideoPicture **)&jarg3; 
  arg4 = (int32_t)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->encodeVideo(arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1encodeAudio(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jlong jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IPacket *arg2 = (com::xuggle::xuggler::IPacket *) 0 ;
  com::xuggle::xuggler::IAudioSamples *arg3 = (com::xuggle::xuggler::IAudioSamples *) 0 ;
  uint32_t arg4 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IPacket **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IAudioSamples **)&jarg3; 
  arg4 = (uint32_t)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->encodeAudio(arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1make_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Direction arg1 ;
  com::xuggle::xuggler::IStreamCoder *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (com::xuggle::xuggler::IStreamCoder::Direction)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStreamCoder *)com::xuggle::xuggler::IStreamCoder::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStreamCoder **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getCodecTag(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getCodecTag();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setCodecTag(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setCodecTag(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getNumProperties(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumProperties();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getPropertyMetaData_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IProperty *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IProperty *)(arg1)->getPropertyMetaData(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IProperty **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getPropertyMetaData_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IProperty *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IProperty *)(arg1)->getPropertyMetaData((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IProperty **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setProperty_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,(char const *)arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setProperty_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jdouble jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (double)jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setProperty_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  int64_t arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (int64_t)jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setProperty_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jboolean jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = jarg3 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setProperty_1_1SWIG_14(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3, jobject jarg3_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IRational *arg3 = (com::xuggle::xuggler::IRational *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = *(com::xuggle::xuggler::IRational **)&jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getPropertyAsString(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getPropertyAsString((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  free(result);
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getPropertyAsDouble(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jdouble jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (double)(arg1)->getPropertyAsDouble((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jdouble)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getPropertyAsLong(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getPropertyAsLong((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getPropertyAsRational(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->getPropertyAsRational((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getPropertyAsBoolean(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->getPropertyAsBoolean((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1isOpen(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isOpen();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getDefaultAudioFrameSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getDefaultAudioFrameSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setDefaultAudioFrameSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setDefaultAudioFrameSize(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1make_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jint jarg1, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Direction arg1 ;
  com::xuggle::xuggler::IStreamCoder *arg2 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IStreamCoder *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg2_;
  arg1 = (com::xuggle::xuggler::IStreamCoder::Direction)jarg1; 
  arg2 = *(com::xuggle::xuggler::IStreamCoder **)&jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStreamCoder *)com::xuggle::xuggler::IStreamCoder::make(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStreamCoder **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getNumDroppedFrames(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getNumDroppedFrames();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setAutomaticallyStampPacketsForStream(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setAutomaticallyStampPacketsForStream(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getAutomaticallyStampPacketsForStream(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->getAutomaticallyStampPacketsForStream();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setCodecID(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::ICodec::ID arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (com::xuggle::xuggler::ICodec::ID)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setCodecID(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setExtraData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jint jarg3, jint jarg4, jboolean jarg5) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::ferry::IBuffer *arg2 = (com::xuggle::ferry::IBuffer *) 0 ;
  int32_t arg3 ;
  int32_t arg4 ;
  bool arg5 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::ferry::IBuffer **)&jarg2; 
  arg3 = (int32_t)jarg3; 
  arg4 = (int32_t)jarg4; 
  arg5 = jarg5 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setExtraData(arg2,arg3,arg4,arg5);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getExtraData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jint jarg3, jint jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::ferry::IBuffer *arg2 = (com::xuggle::ferry::IBuffer *) 0 ;
  int32_t arg3 ;
  int32_t arg4 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::ferry::IBuffer **)&jarg2; 
  arg3 = (int32_t)jarg3; 
  arg4 = (int32_t)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getExtraData(arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getExtraDataSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getExtraDataSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1COMPLIANCE_1VERY_1STRICT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance)com::xuggle::xuggler::IStreamCoder::COMPLIANCE_VERY_STRICT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1COMPLIANCE_1STRICT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance)com::xuggle::xuggler::IStreamCoder::COMPLIANCE_STRICT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1COMPLIANCE_1NORMAL_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance)com::xuggle::xuggler::IStreamCoder::COMPLIANCE_NORMAL;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1COMPLIANCE_1UNOFFICIAL_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance)com::xuggle::xuggler::IStreamCoder::COMPLIANCE_UNOFFICIAL;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1COMPLIANCE_1EXPERIMENTAL_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance)com::xuggle::xuggler::IStreamCoder::COMPLIANCE_EXPERIMENTAL;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1getStandardsCompliance(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance)(arg1)->getStandardsCompliance();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setStandardsCompliance(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IStreamCoder::CodecStandardsCompliance)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setStandardsCompliance(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1open_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IMetaData *arg2 = (com::xuggle::xuggler::IMetaData *) 0 ;
  com::xuggle::xuggler::IMetaData *arg3 = (com::xuggle::xuggler::IMetaData *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IMetaData **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IMetaData **)&jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->open(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1make_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jint jarg1, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Direction arg1 ;
  com::xuggle::xuggler::ICodec *arg2 = (com::xuggle::xuggler::ICodec *) 0 ;
  com::xuggle::xuggler::IStreamCoder *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg2_;
  arg1 = (com::xuggle::xuggler::IStreamCoder::Direction)jarg1; 
  arg2 = *(com::xuggle::xuggler::ICodec **)&jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStreamCoder *)com::xuggle::xuggler::IStreamCoder::make(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStreamCoder **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1make_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder::Direction arg1 ;
  com::xuggle::xuggler::ICodec::ID arg2 ;
  com::xuggle::xuggler::IStreamCoder *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (com::xuggle::xuggler::IStreamCoder::Direction)jarg1; 
  arg2 = (com::xuggle::xuggler::ICodec::ID)jarg2; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStreamCoder *)com::xuggle::xuggler::IStreamCoder::make(arg1,arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStreamCoder **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStreamCoder_1setProperty_1_1SWIG_15(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStreamCoder *arg1 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IMetaData *arg2 = (com::xuggle::xuggler::IMetaData *) 0 ;
  com::xuggle::xuggler::IMetaData *arg3 = (com::xuggle::xuggler::IMetaData *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IStreamCoder **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IMetaData **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IMetaData **)&jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IIndexEntry_1IINDEX_1FLAG_1KEYFRAME_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)com::xuggle::xuggler::IIndexEntry::IINDEX_FLAG_KEYFRAME;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IIndexEntry_1make(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2, jint jarg3, jint jarg4, jint jarg5) {
  jlong jresult = 0 ;
  int64_t arg1 ;
  int64_t arg2 ;
  int32_t arg3 ;
  int32_t arg4 ;
  int32_t arg5 ;
  com::xuggle::xuggler::IIndexEntry *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int64_t)jarg1; 
  arg2 = (int64_t)jarg2; 
  arg3 = (int32_t)jarg3; 
  arg4 = (int32_t)jarg4; 
  arg5 = (int32_t)jarg5; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IIndexEntry *)com::xuggle::xuggler::IIndexEntry::make(arg1,arg2,arg3,arg4,arg5);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IIndexEntry **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IIndexEntry_1getPosition(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IIndexEntry *arg1 = (com::xuggle::xuggler::IIndexEntry *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IIndexEntry **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getPosition();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IIndexEntry_1getTimeStamp(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IIndexEntry *arg1 = (com::xuggle::xuggler::IIndexEntry *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IIndexEntry **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getTimeStamp();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IIndexEntry_1getFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IIndexEntry *arg1 = (com::xuggle::xuggler::IIndexEntry *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IIndexEntry **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getFlags();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IIndexEntry_1getSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IIndexEntry *arg1 = (com::xuggle::xuggler::IIndexEntry *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IIndexEntry **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IIndexEntry_1getMinDistance(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IIndexEntry *arg1 = (com::xuggle::xuggler::IIndexEntry *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IIndexEntry **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getMinDistance();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IIndexEntry_1isKeyFrame(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IIndexEntry *arg1 = (com::xuggle::xuggler::IIndexEntry *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IIndexEntry **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isKeyFrame();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getDirection(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IStream::Direction result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStream::Direction)(arg1)->getDirection();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getIndex();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getId(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getId();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getStreamCoder(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IStreamCoder *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStreamCoder *)(arg1)->getStreamCoder();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStreamCoder **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getFrameRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->getFrameRate();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getTimeBase(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->getTimeBase();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getStartTime(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getStartTime();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getDuration(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getDuration();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getCurrentDts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getCurrentDts();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getNumIndexEntries(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)(arg1)->getNumIndexEntries();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getNumFrames(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getNumFrames();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getSampleAspectRatio(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->getSampleAspectRatio();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1setSampleAspectRatio(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IRational *arg2 = (com::xuggle::xuggler::IRational *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IRational **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setSampleAspectRatio(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getLanguage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getLanguage();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1setLanguage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setLanguage((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getContainer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IContainer *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IContainer *)(arg1)->getContainer();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IContainer **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1setStreamCoder_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IStreamCoder *arg2 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IStreamCoder **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setStreamCoder(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getParseType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IStream::ParseType result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStream::ParseType)(arg1)->getParseType();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1setParseType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IStream::ParseType arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IStream::ParseType)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setParseType(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getMetaData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IMetaData *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IMetaData *)(arg1)->getMetaData();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IMetaData **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1setMetaData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IMetaData *arg2 = (com::xuggle::xuggler::IMetaData *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IMetaData **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setMetaData(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1stampOutputPacket(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IPacket *arg2 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IPacket **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->stampOutputPacket(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1setStreamCoder_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jboolean jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IStreamCoder *arg2 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  bool arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IStreamCoder **)&jarg2; 
  arg3 = jarg3 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setStreamCoder(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1findTimeStampEntryInIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jint jarg3) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int64_t arg2 ;
  int32_t arg3 ;
  com::xuggle::xuggler::IIndexEntry *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  arg3 = (int32_t)jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IIndexEntry *)(arg1)->findTimeStampEntryInIndex(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IIndexEntry **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1findTimeStampPositionInIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jint jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int64_t arg2 ;
  int32_t arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = (int64_t)jarg2; 
  arg3 = (int32_t)jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->findTimeStampPositionInIndex(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1getIndexEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IIndexEntry *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IIndexEntry *)(arg1)->getIndexEntry(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IIndexEntry **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1addIndexEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  com::xuggle::xuggler::IIndexEntry *arg2 = (com::xuggle::xuggler::IIndexEntry *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IIndexEntry **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->addIndexEntry(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IStream_1setId(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IStream *arg1 = (com::xuggle::xuggler::IStream *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IStream **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setId(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1setInputFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  char *arg2 = (char *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setInputFormat((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1setOutputFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jstring jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setOutputFormat((char const *)arg2,(char const *)arg3,(char const *)arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getInputFormatShortName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getInputFormatShortName();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getInputFormatLongName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getInputFormatLongName();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputFormatShortName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getOutputFormatShortName();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputFormatLongName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getOutputFormatLongName();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputFormatMimeType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getOutputFormatMimeType();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1make(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IContainerFormat *)com::xuggle::xuggler::IContainerFormat::make();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IContainerFormat **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1FLAG_1NOFILE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainerFormat::Flags)com::xuggle::xuggler::IContainerFormat::FLAG_NOFILE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1FLAG_1NEEDNUMBER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainerFormat::Flags)com::xuggle::xuggler::IContainerFormat::FLAG_NEEDNUMBER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1FLAG_1SHOW_1IDS_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainerFormat::Flags)com::xuggle::xuggler::IContainerFormat::FLAG_SHOW_IDS;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1FLAG_1RAWPICTURE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainerFormat::Flags)com::xuggle::xuggler::IContainerFormat::FLAG_RAWPICTURE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1FLAG_1GLOBALHEADER_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainerFormat::Flags)com::xuggle::xuggler::IContainerFormat::FLAG_GLOBALHEADER;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1FLAG_1NOTIMESTAMPS_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainerFormat::Flags)com::xuggle::xuggler::IContainerFormat::FLAG_NOTIMESTAMPS;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1FLAG_1GENERIC_1INDEX_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainerFormat::Flags)com::xuggle::xuggler::IContainerFormat::FLAG_GENERIC_INDEX;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1FLAG_1TS_1DISCONT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainerFormat::Flags)com::xuggle::xuggler::IContainerFormat::FLAG_TS_DISCONT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getInputFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getInputFlags();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1setInputFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setInputFlags(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getInputFlag(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IContainerFormat::Flags)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->getInputFlag(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1setInputFlag(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jboolean jarg3) {
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags arg2 ;
  bool arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IContainerFormat::Flags)jarg2; 
  arg3 = jarg3 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setInputFlag(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getOutputFlags();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1setOutputFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setOutputFlags(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputFlag(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IContainerFormat::Flags)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->getOutputFlag(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1setOutputFlag(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jboolean jarg3) {
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  com::xuggle::xuggler::IContainerFormat::Flags arg2 ;
  bool arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IContainerFormat::Flags)jarg2; 
  arg3 = jarg3 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setOutputFlag(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1isOutput(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isOutput();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1isInput(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isInput();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputExtensions(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getOutputExtensions();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputDefaultAudioCodec(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec::ID)(arg1)->getOutputDefaultAudioCodec();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputDefaultVideoCodec(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec::ID)(arg1)->getOutputDefaultVideoCodec();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputDefaultSubtitleCodec(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec::ID)(arg1)->getOutputDefaultSubtitleCodec();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputNumCodecsSupported(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getOutputNumCodecsSupported();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputCodecID(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  int32_t arg2 ;
  com::xuggle::xuggler::ICodec::ID result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::ICodec::ID)(arg1)->getOutputCodecID(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputCodecTag_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  int32_t arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getOutputCodecTag(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getOutputCodecTag_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  com::xuggle::xuggler::ICodec::ID arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = (com::xuggle::xuggler::ICodec::ID)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getOutputCodecTag(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1isCodecSupportedForOutput(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  com::xuggle::xuggler::ICodec::ID arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  arg2 = (com::xuggle::xuggler::ICodec::ID)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isCodecSupportedForOutput(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getNumInstalledInputFormats(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::IContainerFormat::getNumInstalledInputFormats();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getInstalledInputFormat(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int32_t arg1 ;
  com::xuggle::xuggler::IContainerFormat *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IContainerFormat *)com::xuggle::xuggler::IContainerFormat::getInstalledInputFormat(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IContainerFormat **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getNumInstalledOutputFormats(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::IContainerFormat::getNumInstalledOutputFormats();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainerFormat_1getInstalledOutputFormat(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int32_t arg1 ;
  com::xuggle::xuggler::IContainerFormat *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IContainerFormat *)com::xuggle::xuggler::IContainerFormat::getInstalledOutputFormat(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IContainerFormat **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setInputBufferLength(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  uint32_t arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (uint32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setInputBufferLength(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getInputBufferLength(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  uint32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (uint32_t)(arg1)->getInputBufferLength();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1isOpened(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isOpened();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1isHeaderWritten(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->isHeaderWritten();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1open_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3, jlong jarg4, jobject jarg4_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IContainer::Type arg3 ;
  com::xuggle::xuggler::IContainerFormat *arg4 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg4_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (com::xuggle::xuggler::IContainer::Type)jarg3; 
  arg4 = *(com::xuggle::xuggler::IContainerFormat **)&jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->open((char const *)arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1open_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3, jlong jarg4, jobject jarg4_, jboolean jarg5, jboolean jarg6) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IContainer::Type arg3 ;
  com::xuggle::xuggler::IContainerFormat *arg4 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  bool arg5 ;
  bool arg6 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg4_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (com::xuggle::xuggler::IContainer::Type)jarg3; 
  arg4 = *(com::xuggle::xuggler::IContainerFormat **)&jarg4; 
  arg5 = jarg5 ? true : false; 
  arg6 = jarg6 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->open((char const *)arg2,arg3,arg4,arg5,arg6);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getContainerFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IContainerFormat *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IContainerFormat *)(arg1)->getContainerFormat();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IContainerFormat **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1close(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->close();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IContainer::Type result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IContainer::Type)(arg1)->getType();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getNumStreams(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumStreams();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getStream(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  uint32_t arg2 ;
  com::xuggle::xuggler::IStream *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (uint32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStream *)(arg1)->getStream(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStream **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1addNewStream_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IStream *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStream *)(arg1)->addNewStream(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStream **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1writeHeader(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->writeHeader();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1writeTrailer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->writeTrailer();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1readNextPacket(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IPacket *arg2 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IPacket **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->readNextPacket(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1writePacket_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jboolean jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IPacket *arg2 = (com::xuggle::xuggler::IPacket *) 0 ;
  bool arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IPacket **)&jarg2; 
  arg3 = jarg3 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->writePacket(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1writePacket_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IPacket *arg2 = (com::xuggle::xuggler::IPacket *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IPacket **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->writePacket(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1make_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IContainer *)com::xuggle::xuggler::IContainer::make();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IContainer **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1queryStreamMetaData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->queryStreamMetaData();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1seekKeyFrame_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jint jarg4) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t arg2 ;
  int64_t arg3 ;
  int32_t arg4 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  arg3 = (int64_t)jarg3; 
  arg4 = (int32_t)jarg4; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->seekKeyFrame(arg2,arg3,arg4);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getDuration(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getDuration();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getStartTime(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getStartTime();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getFileSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getFileSize();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getBitRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getBitRate();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getNumProperties(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getNumProperties();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getPropertyMetaData_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t arg2 ;
  com::xuggle::xuggler::IProperty *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IProperty *)(arg1)->getPropertyMetaData(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IProperty **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getPropertyMetaData_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IProperty *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IProperty *)(arg1)->getPropertyMetaData((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IProperty **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setProperty_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,(char const *)arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setProperty_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jdouble jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (double)jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setProperty_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  int64_t arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (int64_t)jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setProperty_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jboolean jarg3) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = jarg3 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setProperty_1_1SWIG_14(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3, jobject jarg3_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IRational *arg3 = (com::xuggle::xuggler::IRational *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = *(com::xuggle::xuggler::IRational **)&jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty((char const *)arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getPropertyAsString(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getPropertyAsString((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  free(result);
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getPropertyAsDouble(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jdouble jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (double)(arg1)->getPropertyAsDouble((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jdouble)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getPropertyAsLong(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)(arg1)->getPropertyAsLong((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getPropertyAsRational(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IRational *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IRational *)(arg1)->getPropertyAsRational((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IRational **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getPropertyAsBoolean(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->getPropertyAsBoolean((char const *)arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1FLAG_1GENPTS_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainer::Flags)com::xuggle::xuggler::IContainer::FLAG_GENPTS;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1FLAG_1IGNIDX_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainer::Flags)com::xuggle::xuggler::IContainer::FLAG_IGNIDX;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1FLAG_1NONBLOCK_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainer::Flags)com::xuggle::xuggler::IContainer::FLAG_NONBLOCK;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1FLAG_1IGNDTS_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainer::Flags)com::xuggle::xuggler::IContainer::FLAG_IGNDTS;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1FLAG_1NOFILLIN_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainer::Flags)com::xuggle::xuggler::IContainer::FLAG_NOFILLIN;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1FLAG_1NOPARSE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainer::Flags)com::xuggle::xuggler::IContainer::FLAG_NOPARSE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1FLAG_1RTP_1HINT_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer::Flags result;
  
  (void)jenv;
  (void)jcls;
  result = (com::xuggle::xuggler::IContainer::Flags)com::xuggle::xuggler::IContainer::FLAG_RTP_HINT;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getFlags();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setFlags(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setFlags(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getFlag(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IContainer::Flags arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IContainer::Flags)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->getFlag(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setFlag(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jboolean jarg3) {
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IContainer::Flags arg2 ;
  bool arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (com::xuggle::xuggler::IContainer::Flags)jarg2; 
  arg3 = jarg3 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setFlag(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getURL(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getURL();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1flushPackets(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->flushPackets();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getReadRetryCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getReadRetryCount();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setReadRetryCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setReadRetryCount(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jboolean JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1canStreamsBeAddedDynamically(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (bool)(arg1)->canStreamsBeAddedDynamically();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getMetaData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IMetaData *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IMetaData *)(arg1)->getMetaData();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IMetaData **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setMetaData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IMetaData *arg2 = (com::xuggle::xuggler::IMetaData *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IMetaData **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setMetaData(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1createSDPData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::ferry::IBuffer *arg2 = (com::xuggle::ferry::IBuffer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = *(com::xuggle::ferry::IBuffer **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->createSDPData(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setForcedAudioCodec(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::ICodec::ID arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (com::xuggle::xuggler::ICodec::ID)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setForcedAudioCodec(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setForcedVideoCodec(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::ICodec::ID arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (com::xuggle::xuggler::ICodec::ID)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setForcedVideoCodec(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setForcedSubtitleCodec(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::ICodec::ID arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (com::xuggle::xuggler::ICodec::ID)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setForcedSubtitleCodec(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1SEEK_1FLAG_1BACKWARDS_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)com::xuggle::xuggler::IContainer::SEEK_FLAG_BACKWARDS;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1SEEK_1FLAG_1BYTE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)com::xuggle::xuggler::IContainer::SEEK_FLAG_BYTE;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1SEEK_1FLAG_1ANY_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)com::xuggle::xuggler::IContainer::SEEK_FLAG_ANY;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1SEEK_1FLAG_1FRAME_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)com::xuggle::xuggler::IContainer::SEEK_FLAG_FRAME;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1seekKeyFrame_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jlong jarg4, jlong jarg5, jint jarg6) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t arg2 ;
  int64_t arg3 ;
  int64_t arg4 ;
  int64_t arg5 ;
  int32_t arg6 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  arg3 = (int64_t)jarg3; 
  arg4 = (int64_t)jarg4; 
  arg5 = (int64_t)jarg5; 
  arg6 = (int32_t)jarg6; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->seekKeyFrame(arg2,arg3,arg4,arg5,arg6);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setPreload(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setPreload(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getPreload(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getPreload();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setMaxDelay(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t arg2 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (int32_t)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setMaxDelay(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getMaxDelay(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getMaxDelay();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1addNewStream_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::ICodec::ID arg2 ;
  com::xuggle::xuggler::IStream *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = (com::xuggle::xuggler::ICodec::ID)jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStream *)(arg1)->addNewStream(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStream **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1addNewStream_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::ICodec *arg2 = (com::xuggle::xuggler::ICodec *) 0 ;
  com::xuggle::xuggler::IStream *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::ICodec **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStream *)(arg1)->addNewStream(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStream **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1addNewStream_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IStreamCoder *arg2 = (com::xuggle::xuggler::IStreamCoder *) 0 ;
  com::xuggle::xuggler::IStream *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IStreamCoder **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IStream *)(arg1)->addNewStream(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IStream **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setProperty_1_1SWIG_15(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IMetaData *arg2 = (com::xuggle::xuggler::IMetaData *) 0 ;
  com::xuggle::xuggler::IMetaData *arg3 = (com::xuggle::xuggler::IMetaData *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IMetaData **)&jarg2; 
  arg3 = *(com::xuggle::xuggler::IMetaData **)&jarg3; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setProperty(arg2,arg3);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1getFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IContainerFormat *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IContainerFormat *)(arg1)->getFormat();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IContainerFormat **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1setFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  com::xuggle::xuggler::IContainerFormat *arg2 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IContainerFormat **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->setFormat(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1make_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IContainerFormat *arg1 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  com::xuggle::xuggler::IContainer *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IContainerFormat **)&jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IContainer *)com::xuggle::xuggler::IContainer::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IContainer **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IContainer_1open_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3, jlong jarg4, jobject jarg4_, jboolean jarg5, jboolean jarg6, jlong jarg7, jobject jarg7_, jlong jarg8, jobject jarg8_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IContainer *arg1 = (com::xuggle::xuggler::IContainer *) 0 ;
  char *arg2 = (char *) 0 ;
  com::xuggle::xuggler::IContainer::Type arg3 ;
  com::xuggle::xuggler::IContainerFormat *arg4 = (com::xuggle::xuggler::IContainerFormat *) 0 ;
  bool arg5 ;
  bool arg6 ;
  com::xuggle::xuggler::IMetaData *arg7 = (com::xuggle::xuggler::IMetaData *) 0 ;
  com::xuggle::xuggler::IMetaData *arg8 = (com::xuggle::xuggler::IMetaData *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg4_;
  (void)jarg7_;
  (void)jarg8_;
  arg1 = *(com::xuggle::xuggler::IContainer **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (com::xuggle::xuggler::IContainer::Type)jarg3; 
  arg4 = *(com::xuggle::xuggler::IContainerFormat **)&jarg4; 
  arg5 = jarg5 ? true : false; 
  arg6 = jarg6 ? true : false; 
  arg7 = *(com::xuggle::xuggler::IMetaData **)&jarg7; 
  arg8 = *(com::xuggle::xuggler::IMetaData **)&jarg8; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->open((char const *)arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1wrap(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  com::xuggle::xuggler::IMediaDataWrapper *arg1 = (com::xuggle::xuggler::IMediaDataWrapper *) 0 ;
  com::xuggle::xuggler::IMediaData *arg2 = (com::xuggle::xuggler::IMediaData *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1; 
  arg2 = *(com::xuggle::xuggler::IMediaData **)&jarg2; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->wrap(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1setKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  com::xuggle::xuggler::IMediaDataWrapper *arg1 = (com::xuggle::xuggler::IMediaDataWrapper *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return ;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      (arg1)->setKey(arg2);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1make(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaData *arg1 = (com::xuggle::xuggler::IMediaData *) 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaData **)&jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IMediaDataWrapper *)com::xuggle::xuggler::IMediaDataWrapper::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IMediaDataWrapper **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1getPacket(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *arg1 = (com::xuggle::xuggler::IMediaDataWrapper *) 0 ;
  com::xuggle::xuggler::IPacket *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPacket *)com_xuggle_xuggler_IMediaDataWrapper_getPacket(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IPacket **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1getAudioSamples(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *arg1 = (com::xuggle::xuggler::IMediaDataWrapper *) 0 ;
  com::xuggle::xuggler::IAudioSamples *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioSamples *)com_xuggle_xuggler_IMediaDataWrapper_getAudioSamples(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IAudioSamples **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1getVideoPicture(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *arg1 = (com::xuggle::xuggler::IMediaDataWrapper *) 0 ;
  com::xuggle::xuggler::IVideoPicture *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IVideoPicture *)com_xuggle_xuggler_IMediaDataWrapper_getVideoPicture(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IVideoPicture **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1getMediaDataWrapper(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *arg1 = (com::xuggle::xuggler::IMediaDataWrapper *) 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IMediaDataWrapper *)com_xuggle_xuggler_IMediaDataWrapper_getMediaDataWrapper(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IMediaDataWrapper **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1unwrapPacket(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *arg1 = (com::xuggle::xuggler::IMediaDataWrapper *) 0 ;
  com::xuggle::xuggler::IPacket *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IPacket *)com_xuggle_xuggler_IMediaDataWrapper_unwrapPacket(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IPacket **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1unwrapAudioSamples(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *arg1 = (com::xuggle::xuggler::IMediaDataWrapper *) 0 ;
  com::xuggle::xuggler::IAudioSamples *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IAudioSamples *)com_xuggle_xuggler_IMediaDataWrapper_unwrapAudioSamples(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IAudioSamples **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1unwrapVideoPicture(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *arg1 = (com::xuggle::xuggler::IMediaDataWrapper *) 0 ;
  com::xuggle::xuggler::IVideoPicture *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IVideoPicture *)com_xuggle_xuggler_IMediaDataWrapper_unwrapVideoPicture(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IVideoPicture **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IMediaDataWrapper_1unwrapMediaDataWrapper(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *arg1 = (com::xuggle::xuggler::IMediaDataWrapper *) 0 ;
  com::xuggle::xuggler::IMediaDataWrapper *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IMediaDataWrapper *)com_xuggle_xuggler_IMediaDataWrapper_unwrapMediaDataWrapper(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IMediaDataWrapper **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1NO_1PTS_1get(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  long long result;
  
  (void)jenv;
  (void)jcls;
  result = (long long)com::xuggle::xuggler::Global::NO_PTS;
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1DEFAULT_1PTS_1PER_1SECOND_1get(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  long long result;
  
  (void)jenv;
  (void)jcls;
  result = (long long)com::xuggle::xuggler::Global::DEFAULT_PTS_PER_SECOND;
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1getVersion(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  int64_t result;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int64_t)com::xuggle::xuggler::Global::getVersion();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1getVersionMajor(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::Global::getVersionMajor();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1getVersionMinor(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::Global::getVersionMinor();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1getVersionRevision(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::Global::getVersionRevision();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1getVersionStr(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)com::xuggle::xuggler::Global::getVersionStr();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1getAVFormatVersion(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)com::xuggle::xuggler::Global::getAVFormatVersion();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1getAVFormatVersionStr(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)com::xuggle::xuggler::Global::getAVFormatVersionStr();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1getAVCodecVersion(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int)com::xuggle::xuggler::Global::getAVCodecVersion();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1getAVCodecVersionStr(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)com::xuggle::xuggler::Global::getAVCodecVersionStr();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1init(JNIEnv *jenv, jclass jcls) {
  (void)jenv;
  (void)jcls;
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      com::xuggle::xuggler::Global::init();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT void JNICALL Java_com_xuggle_xuggler_XugglerJNI_Global_1setFFmpegLoggingLevel(JNIEnv *jenv, jclass jcls, jint jarg1) {
  int32_t arg1 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      com::xuggle::xuggler::Global::setFFmpegLoggingLevel(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return ;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return ;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return ;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IError_1getType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IError *arg1 = (com::xuggle::xuggler::IError *) 0 ;
  com::xuggle::xuggler::IError::Type result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IError **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IError::Type)(arg1)->getType();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_com_xuggle_xuggler_XugglerJNI_IError_1getDescription(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  com::xuggle::xuggler::IError *arg1 = (com::xuggle::xuggler::IError *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IError **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (char *)(arg1)->getDescription();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IError_1getErrorNumber(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IError *arg1 = (com::xuggle::xuggler::IError *) 0 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(com::xuggle::xuggler::IError **)&jarg1; 
  
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException,
      "invalid native object; delete() likely already called");
    return 0;
  }
  
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)(arg1)->getErrorNumber();
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IError_1make_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int32_t arg1 ;
  com::xuggle::xuggler::IError *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IError *)com::xuggle::xuggler::IError::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IError **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_IError_1make_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  com::xuggle::xuggler::IError::Type arg1 ;
  com::xuggle::xuggler::IError *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (com::xuggle::xuggler::IError::Type)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IError *)com::xuggle::xuggler::IError::make(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  *(com::xuggle::xuggler::IError **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IError_1errorNumberToType(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int32_t arg1 ;
  com::xuggle::xuggler::IError::Type result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int32_t)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (com::xuggle::xuggler::IError::Type)com::xuggle::xuggler::IError::errorNumberToType(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_xuggle_xuggler_XugglerJNI_IError_1typeToErrorNumber(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  com::xuggle::xuggler::IError::Type arg1 ;
  int32_t result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (com::xuggle::xuggler::IError::Type)jarg1; 
  {
    // JNIHelper.swg: Start generated code
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>
    try
    {
      result = (int32_t)com::xuggle::xuggler::IError::typeToErrorNumber(arg1);
    }
    catch(std::invalid_argument & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/IllegalArgumentException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(std::bad_alloc & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        // OK, this is bad and may mean we can't do things like 
        // allocate a new class at this time; but we should have
        // one lying around
        com::xuggle::ferry::JNIHelper *helper = 
        com::xuggle::ferry::JNIHelper::getHelper();
        if (helper) {
          helper->throwOutOfMemoryError();
        }
      }
      return 0;
    }
    catch(std::exception & e)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, e.what());
      }
      return 0;
    }
    catch(...)
    {
      // we don't let a native exception override a java exception
      if (!jenv->ExceptionCheck())
      {
        jclass cls=jenv->FindClass("java/lang/RuntimeException");
        jenv->ThrowNew(cls, "Unhandled and unknown native exception");
      }
      return 0;
    }
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<
    // JNIHelper.swg: End generated code
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIPropertyUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IProperty **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIPixelFormatUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IPixelFormat **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIRationalUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IRational **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGITimeValueUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::ITimeValue **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIMetaDataUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IMetaData **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIMediaDataUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IMediaData **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIPacketUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::xuggler::IMediaData **)&baseptr = *(com::xuggle::xuggler::IPacket **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIAudioSamplesUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::xuggler::IMediaData **)&baseptr = *(com::xuggle::xuggler::IAudioSamples **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIVideoPictureUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::xuggler::IMediaData **)&baseptr = *(com::xuggle::xuggler::IVideoPicture **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGICodecUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::ICodec **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIAudioResamplerUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IAudioResampler **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIVideoResamplerUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IVideoResampler **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIStreamCoderUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IStreamCoder **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIIndexEntryUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IIndexEntry **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIStreamUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IStream **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIContainerFormatUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IContainerFormat **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIContainerUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IContainer **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIMediaDataWrapperUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::xuggler::IMediaData **)&baseptr = *(com::xuggle::xuggler::IMediaDataWrapper **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGGlobalUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::Global **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_com_xuggle_xuggler_XugglerJNI_SWIGIErrorUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(com::xuggle::ferry::RefCounted **)&baseptr = *(com::xuggle::xuggler::IError **)&jarg1;
    return baseptr;
}

#ifdef __cplusplus
}
#endif

